<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Live Ergebnisdienst</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f172a;
      --bg-alt: #111c32;
      --card: #1e293b;
      --border: #293549;
      --accent: #60a5fa;
      --accent-soft: rgba(96, 165, 250, 0.12);
      --text: #e2e8f0;
      --muted: #94a3b8;
      --danger: #f87171;
      --warning: #fbbf24;
      font-family: "Inter", "SF Pro Text", "Segoe UI", Roboto, Arial, sans-serif;
      font-size: 15px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: linear-gradient(160deg, var(--bg) 0%, var(--bg-alt) 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1.8rem 1.2rem 0.8rem;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.6rem, 2.5vw, 2.2rem);
      font-weight: 700;
    }

    header p {
      margin: 0.4rem 0 0;
      font-size: 0.8rem;
      color: var(--muted);
    }

    main {
      width: min(980px, 92vw);
      margin: 0 auto 1.4rem;
      flex: 1 0 auto;
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }

    .control-panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 0.85rem clamp(0.8rem, 2.2vw, 1.4rem);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 0.75rem clamp(0.5rem, 1.5vw, 1rem);
      box-shadow: 0 22px 48px -28px rgba(6, 10, 20, 0.65);
    }

    .control {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 600;
      color: var(--muted);
    }

    select,
    input[type="date"] {
      appearance: none;
      border: 1px solid var(--border);
      border-radius: 0.6rem;
      padding: 0.5rem 0.7rem;
      font-size: 0.9rem;
      color: var(--text);
      background: rgba(15, 23, 42, 0.7);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    select:focus,
    input[type="date"]:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.25);
    }

    .matchday-group {
      display: flex;
      width: 100%;
    }

    .matchday-select {
      border: 1px solid var(--border);
      border-radius: 0.6rem;
      padding: 0.5rem 0.7rem;
      font-size: 0.9rem;
      color: var(--text);
      background: rgba(15, 23, 42, 0.7);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      text-align: center;
      appearance: none;
      -webkit-appearance: none;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      width: 100%;
    }

    .matchday-select:focus-visible {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.25);
    }

    #status-box {
      padding: 0.65rem 0.9rem;
      border-radius: 0.7rem;
      font-size: 0.82rem;
      background: var(--accent-soft);
      color: var(--accent);
      border: 1px solid rgba(96, 165, 250, 0.32);
      display: flex;
      align-items: center;
      gap: 0.45rem;
      min-height: 2.6rem;
    }

    #status-box[data-level="error"] {
      background: rgba(248, 113, 113, 0.12);
      color: var(--danger);
      border-color: rgba(248, 113, 113, 0.28);
    }

    #status-box[data-level="warning"] {
      background: rgba(251, 191, 36, 0.14);
      color: var(--warning);
      border-color: rgba(251, 191, 36, 0.28);
    }

    .content-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: clamp(0.75rem, 2vw, 1.2rem);
      box-shadow: 0 24px 52px -32px rgba(5, 10, 22, 0.7);
    }

    .content-card h2 {
      margin: 0 0 1rem;
      font-size: 1.1rem;
    }

    .table-wrapper {
      overflow-x: auto;
      border-radius: 0.85rem;
      border: 1px solid var(--border);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      background: var(--card);
    }

    #results-table {
      font-size: 0.82rem;
    }

    #results-table td {
      white-space: normal;
    }

    thead {
      background: rgba(148, 163, 184, 0.08);
    }

    th,
    td {
      padding: 0.55rem 0.75rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.12);
      text-align: left;
      white-space: nowrap;
    }

    tbody tr:hover {
      background: rgba(148, 163, 184, 0.12);
    }

    #standings-table tr.standings-empty td {
      text-align: center;
      font-style: italic;
      color: var(--muted);
      padding: 0.85rem;
    }

    td.score,
    .col-score {
      font-weight: 600;
      font-size: 0.95rem;
      text-align: right;
    }

    .col-home {
      font-weight: 600;
    }

    .col-away {
      color: var(--muted);
    }

    .col-home,
    .col-away {
      line-height: 1.25;
    }

    .team-name {
      display: block;
    }

    .empty-state {
      margin: 1.4rem 0 0;
      text-align: center;
      padding: 1.6rem;
      border-radius: 0.75rem;
      background: rgba(148, 163, 184, 0.08);
      border: 1px dashed var(--border);
      color: var(--muted);
    }

    .hidden {
      display: none !important;
    }

    footer {
      text-align: center;
      padding: 1.1rem 0.8rem 1.6rem;
      font-size: 0.72rem;
      color: var(--muted);
    }

    footer a {
      color: var(--accent);
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }

    @media (max-width: 720px) {
      header {
        padding-top: 1.4rem;
      }

      .content-card,
      .control-panel {
        border-radius: 0.65rem;
      }

      th,
      td {
        padding: 0.45rem;
      }

      #results-table thead {
        display: none;
      }

      #results-table,
      #results-table tbody {
        display: block;
        width: 100%;
      }

      #results-table tbody tr {
        display: grid;
        grid-template-columns: 1fr auto;
        grid-template-areas:
          "home score"
          "away score";
        gap: 0.2rem 0.5rem;
        padding: 0.5rem 0.55rem;
        border: 1px solid rgba(148, 163, 184, 0.16);
        border-radius: 0.6rem;
        background: rgba(15, 23, 42, 0.7);
        margin-bottom: 0.45rem;
      }

      #results-table tbody tr:last-child {
        margin-bottom: 0;
      }

      #results-table tbody tr td {
        padding: 0;
        border: 0;
        font-size: 0.84rem;
      }

      #results-table tbody tr td:nth-child(1) {
        grid-area: home;
      }

      #results-table tbody tr td:nth-child(2) {
        grid-area: away;
      }

      #results-table tbody tr td:nth-child(3) {
        grid-area: score;
        justify-self: end;
        align-self: center;
        font-size: 1rem;
      }

      #results-table tbody tr td:nth-child(1),
      #results-table tbody tr td:nth-child(2) {
        display: flex;
        flex-direction: column;
        gap: 0.1rem;
      }

      #results-table tbody tr:hover {
        background: rgba(96, 165, 250, 0.12);
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Live Ergebnisdienst</h1>
  <p>Aktuelle Ergebnisse für Fußball und Tennis – gefiltert nach Datum und Wettbewerb.</p>
  </header>

  <main>
    <section class="control-panel" aria-label="Filter">
      <div class="control">
        <label for="sport-select">Sportart</label>
        <select id="sport-select">
          <option value="football">Fußball</option>
          <option value="tennis">Tennis</option>
        </select>
      </div>

      <div class="control" id="league-control">
        <label for="league-select">Wettbewerb</label>
        <select id="league-select"></select>
      </div>

      <div class="control">
        <label for="matchday-current">Spieltag</label>
        <div class="matchday-group" id="matchday-group" role="group" aria-label="Spieltag auswählen">
          <select id="matchday-current" class="matchday-select" aria-label="Aktueller Spieltag"></select>
        </div>
      </div>
    </section>

    <div id="status-box" role="status" aria-live="polite">Initialisiere Live-Daten …</div>

    <section id="results-section" class="content-card" aria-live="polite">
      <h2>Ergebnisse</h2>
      <div class="table-wrapper"
           id="results-wrapper">
        <table id="results-table">
          <thead>
            <tr>
              <th>Heim</th>
              <th>Gast</th>
              <th>Ergebnis</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <p class="empty-state hidden" id="no-results">Keine Ergebnisse für den gewählten Tag gefunden.</p>
    </section>

    <section id="table-section" class="content-card hidden">
      <h2>Tabellenstand</h2>
      <div class="table-wrapper">
        <table id="standings-table">
          <thead>
            <tr>
              <th>Rang</th>
              <th>Team</th>
              <th>S</th>
              <th>U</th>
              <th>N</th>
              <th>Tore</th>
              <th>Pkt</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
  </main>

  <footer>
    <span>Automatische Aktualisierung alle 5&nbsp;ms (netzwerkschonender Abruf mit Drosselung). Bei ausbleibenden Live-Daten wird eine Simulation angezeigt.</span>
  </footer>

  <script>
    (() => {
      const POLL_INTERVAL_MS = 5; // UI loop cadence (requirement)
      const MIN_FETCH_INTERVAL_MS = 5000; // throttle real network calls (protect remote APIs)
      const FETCH_TIMEOUT_MS = 12000;
      const OPENLIGA_BASE = 'https://api.openligadb.de';

      const DOM = {
        sportSelect: document.getElementById('sport-select'),
        leagueControl: document.getElementById('league-control'),
        leagueSelect: document.getElementById('league-select'),
  matchdayGroup: document.getElementById('matchday-group'),
  matchdayControl: document.getElementById('matchday-current')?.closest('.control'),
        matchdayCurrent: document.getElementById('matchday-current'),
        statusBox: document.getElementById('status-box'),
        resultsTable: document.getElementById('results-table'),
        resultsBody: document.querySelector('#results-table tbody'),
        noResults: document.getElementById('no-results'),
        tableSection: document.getElementById('table-section'),
        standingsBody: document.querySelector('#standings-table tbody')
      };

      const today = new Date();
      const defaultDate = today.toISOString().slice(0, 10);

      const state = {
        sport: 'football',
        league: null,
        date: defaultDate,
        matchdays: [],
        activeMatchdayOrder: null,
        timerId: null,
        lastFetchStart: 0,
        fetchInFlight: false
      };

      const cache = new Map();

      function getCacheEntry(key, ttl) {
        if (!key || !cache.has(key)) {
          return null;
        }
        const entry = cache.get(key);
        if (ttl && ttl > 0) {
          if (Date.now() - entry.timestamp > ttl) {
            cache.delete(key);
            return null;
          }
        }
        return entry.value;
      }

      function setCacheEntry(key, value) {
        if (!key) {
          return;
        }
        cache.set(key, { value, timestamp: Date.now() });
      }

      function decodeBase64Json(base64Text) {
        if (!base64Text) {
          return null;
        }
        try {
          const normalized = base64Text.replace(/\s+/g, '');
          const binary = atob(normalized);
          const bytes = Uint8Array.from(binary, (char) => char.charCodeAt(0));
          const decoded = new TextDecoder('utf-8').decode(bytes);
          return JSON.parse(decoded);
        } catch (error) {
          console.warn('Base64-Dekodierung fehlgeschlagen', error);
          return null;
        }
      }

      async function fetchText(url, { timeout = FETCH_TIMEOUT_MS, headers } = {}) {
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), timeout);
        try {
          const response = await fetch(url, { signal: controller.signal, headers });
          if (!response.ok) {
            const error = new Error(`${response.status} ${response.statusText}`.trim());
            error.status = response.status;
            error.url = url;
            throw error;
          }
          return await response.text();
        } finally {
          clearTimeout(timer);
        }
      }

      async function fetchTextWithCache(url, { cacheKey, ttl = 60000, headers } = {}) {
        const cached = cacheKey ? getCacheEntry(cacheKey, ttl) : null;
        if (cached != null) {
          return cached;
        }
        const value = await fetchText(url, { headers });
        if (cacheKey) {
          setCacheEntry(cacheKey, value);
        }
        return value;
      }
      const FOOTBALL_LEAGUES = [
        {
          id: 'bl1',
          label: '1. Liga',
          shortcut: 'bl1',
          table: true
        },
        {
          id: 'bl2',
          label: '2. Liga',
          shortcut: 'bl2',
          table: true
        },
        {
          id: 'bl3',
          label: '3. Liga',
          shortcut: 'bl3',
          table: true
        }
      ];
      const TENNIS_SCOPE_LABEL = 'ATP Tour & Grand Slam';
      const TENNIS_SOURCES = [
        { tour: 'atp', requireMajor: false },
        { tour: 'wta', requireMajor: true }
      ];

      init();

      function init() {
        populateLeagueOptions();
        DOM.sportSelect.addEventListener('change', onSportChange);
        DOM.leagueSelect.addEventListener('change', onLeagueChange);
        if (DOM.matchdayCurrent) {
          DOM.matchdayCurrent.addEventListener('change', onMatchdaySelect);
        }
        window.addEventListener('focus', () => requestRefresh(true));

        requestRefresh(true);
        startPollingLoop();
      }

      function startPollingLoop() {
        if (state.timerId) {
          clearInterval(state.timerId);
        }
        state.timerId = setInterval(() => {
          if (state.fetchInFlight) {
            return;
          }
          if (Date.now() - state.lastFetchStart < MIN_FETCH_INTERVAL_MS) {
            return;
          }
          requestRefresh(false);
        }, POLL_INTERVAL_MS);
      }

      function onSportChange(event) {
        state.sport = event.target.value;
        if (state.sport !== 'football') {
          state.matchdays = [];
          state.activeMatchdayOrder = null;
          updateMatchdayDisplay();
        }
        if (state.sport === 'football') {
          state.league = state.league || FOOTBALL_LEAGUES[0].id;
        } else {
          state.league = null;
        }
        populateLeagueOptions();
        requestRefresh(true);
      }

      function onLeagueChange(event) {
        if (state.sport === 'football') {
          state.league = event.target.value;
        } else {
          return;
        }
        requestRefresh(true);
      }

      function onMatchdaySelect(event) {
        const select = event.target;
        if (!select || select.selectedIndex < 0) {
          return;
        }
        const rawValue = select.value;
        const matchdayOrder = Number.parseInt(rawValue, 10);
        const metadata = Array.isArray(state.matchdays)
          ? state.matchdays.find((entry) => entry.order === matchdayOrder)
          : null;
        const selectedOption = select.options[select.selectedIndex];
        const optionDates = selectedOption?.dataset?.dates?.split(',') || [];
        const primaryDate = metadata?.primaryDate || selectedOption?.dataset?.primaryDate || optionDates[0] || null;
        const normalizedDate = primaryDate ?? state.date;
        const changed = updateMatchdayState(normalizedDate, Number.isFinite(matchdayOrder) ? matchdayOrder : undefined);
        if (!changed) {
          return;
        }
        requestRefresh(true);
      }

      function resetMatchdayToToday() {
        const todayIso = new Date().toISOString().slice(0, 10);
        const matchdays = Array.isArray(state.matchdays) ? state.matchdays : [];
        let targetDate = todayIso;
        let targetOrder;
        if (matchdays.length) {
          const indexToday = resolveMatchdayIndexByDate(todayIso, matchdays);
          if (indexToday !== -1) {
            targetDate = matchdays[indexToday].primaryDate;
            targetOrder = matchdays[indexToday].order;
          } else {
            const closest = findClosestMatchdayIndex(todayIso, matchdays);
            if (closest !== -1) {
              targetDate = matchdays[closest].primaryDate;
              targetOrder = matchdays[closest].order;
            }
          }
        }
        if (!updateMatchdayState(targetDate, targetOrder)) {
          return;
        }
        requestRefresh(true);
      }

      function updateMatchdayState(newDate, matchdayOrderOverride) {
        const matchdays = Array.isArray(state.matchdays) ? state.matchdays : [];
        const normalizedInputDate = normalizeToIsoDate(newDate);

        if (!matchdays.length) {
          const normalizedFallback = normalizedInputDate || state.date;
          if (!normalizedFallback || normalizedFallback === state.date) {
            return false;
          }
          state.date = normalizedFallback;
          updateMatchdayDisplay();
          return true;
        }

        let targetOrder = Number.isFinite(matchdayOrderOverride)
          ? matchdayOrderOverride
          : Number.parseInt(matchdayOrderOverride, 10);
        if (!Number.isFinite(targetOrder)) {
          targetOrder = null;
        }

        let targetEntry = targetOrder != null
          ? matchdays.find((entry) => entry.order === targetOrder)
          : null;

        if (!targetEntry && normalizedInputDate) {
          targetEntry = matchdays.find((entry) => entry.primaryDate === normalizedInputDate || entry.dates?.includes(normalizedInputDate)) || null;
          if (targetEntry) {
            targetOrder = targetEntry.order;
          }
        }

        let nextDate = targetEntry?.primaryDate || normalizedInputDate || state.date;
        if (!nextDate && targetEntry?.dates?.length) {
          nextDate = targetEntry.dates[0];
        }

        if (targetOrder == null && targetEntry == null) {
          const currentIndex = getCurrentMatchdayIndex();
          const fallbackEntry = currentIndex != null ? matchdays[currentIndex] : matchdays[0];
          if (fallbackEntry) {
            targetEntry = fallbackEntry;
            targetOrder = fallbackEntry.order;
            if (!nextDate) {
              nextDate = fallbackEntry.primaryDate || fallbackEntry.dates?.[0] || state.date;
            }
          }
        }

        const normalizedDate = normalizeToIsoDate(nextDate) || state.date;
        if (normalizedDate == null) {
          return false;
        }

        const orderChanged = typeof targetOrder === 'number' && targetOrder !== state.activeMatchdayOrder;
        const dateChanged = normalizedDate !== state.date;

        if (!orderChanged && !dateChanged) {
          return false;
        }

        state.date = normalizedDate;
        if (typeof targetOrder === 'number') {
          state.activeMatchdayOrder = targetOrder;
        }
        updateMatchdayDisplay();
        return true;
      }

      function updateMatchdayDisplay() {
        if (!DOM.matchdayCurrent) {
          return;
        }
        const matchdays = Array.isArray(state.matchdays) ? state.matchdays : [];
        const select = DOM.matchdayCurrent;
        const showMatchday = state.sport === 'football';
        if (DOM.matchdayControl) {
          DOM.matchdayControl.classList.toggle('hidden', !showMatchday);
        }
        select.disabled = !showMatchday;
        select.innerHTML = '';

        let nextValue = null;
        let hasExplicitSelection = false;

        if (matchdays.length) {
          const activeOrder = determineActiveMatchdayOrder(matchdays);
          matchdays.forEach((entry) => {
            const option = document.createElement('option');
            option.value = String(entry.order);
            option.textContent = entry.label;
            option.dataset.matchdayOrder = entry.order;
            if (entry.primaryDate) {
              option.dataset.primaryDate = entry.primaryDate;
            }
            if (entry.dates?.length) {
              option.dataset.dates = entry.dates.join(',');
            }
            if (entry.order === activeOrder) {
              option.selected = true;
              nextValue = option.value;
              hasExplicitSelection = true;
            }
            select.appendChild(option);
          });

          if (!hasExplicitSelection && select.options.length) {
            select.options[0].selected = true;
            const fallbackOrder = select.options[0].dataset.matchdayOrder ? Number.parseInt(select.options[0].dataset.matchdayOrder, 10) : null;
            if (fallbackOrder != null && !Number.isNaN(fallbackOrder)) {
              state.activeMatchdayOrder = fallbackOrder;
            }
            nextValue = select.options[0].value;
          }
          select.value = nextValue != null ? nextValue : select.options[0]?.value ?? '';
        } else {
          const option = document.createElement('option');
          option.value = state.date;
          option.textContent = formatDateForLocale(state.date) || state.date;
          option.selected = true;
          select.appendChild(option);
        }
      }

      function determineActiveMatchdayOrder(matchdays) {
        if (!matchdays.length) {
          return null;
        }
        if (state.activeMatchdayOrder != null && matchdays.some((entry) => entry.order === state.activeMatchdayOrder)) {
          return state.activeMatchdayOrder;
        }
        const indexByDate = resolveMatchdayIndexByDate(state.date, matchdays);
        if (indexByDate !== -1) {
          const order = matchdays[indexByDate].order;
          state.activeMatchdayOrder = order;
          return order;
        }
        const closestIndex = findClosestMatchdayIndex(state.date, matchdays);
        if (closestIndex !== -1) {
          const order = matchdays[closestIndex].order;
          state.activeMatchdayOrder = order;
          return order;
        }
        return null;
      }

      function resolveMatchdayIndexByDate(isoDate, matchdays) {
        if (!isoDate || !Array.isArray(matchdays)) {
          return -1;
        }
        return matchdays.findIndex((entry) => Array.isArray(entry.dates) && entry.dates.includes(isoDate));
      }

      function findClosestMatchdayIndex(isoDate, matchdays) {
        if (!Array.isArray(matchdays) || !matchdays.length) {
          return -1;
        }
        const reference = normalizeToIsoDate(isoDate);
        const referenceTime = reference ? Date.parse(reference + 'T00:00:00Z') : NaN;
        if (Number.isNaN(referenceTime)) {
          return 0;
        }
        let closestIndex = -1;
        let smallestDelta = Number.POSITIVE_INFINITY;
        matchdays.forEach((entry, index) => {
          if (!entry?.primaryDate) {
            return;
          }
          const time = Date.parse(entry.primaryDate + 'T00:00:00Z');
          if (Number.isNaN(time)) {
            return;
          }
          const delta = Math.abs(time - referenceTime);
          if (delta < smallestDelta) {
            smallestDelta = delta;
            closestIndex = index;
          }
        });
        return closestIndex;
      }

      function getCurrentMatchdayIndex() {
        const matchdays = Array.isArray(state.matchdays) ? state.matchdays : [];
        if (!matchdays.length) {
          return null;
        }
        if (state.activeMatchdayOrder != null) {
          const indexByOrder = matchdays.findIndex((entry) => entry.order === state.activeMatchdayOrder);
          if (indexByOrder !== -1) {
            return indexByOrder;
          }
        }
        const indexByDate = resolveMatchdayIndexByDate(state.date, matchdays);
        if (indexByDate !== -1) {
          return indexByDate;
        }
        const closestIndex = findClosestMatchdayIndex(state.date, matchdays);
        return closestIndex !== -1 ? closestIndex : null;
      }

      function ensureActiveMatchday(matchdays) {
        if (!Array.isArray(matchdays) || !matchdays.length) {
          state.activeMatchdayOrder = null;
          return;
        }
        if (state.activeMatchdayOrder != null && matchdays.some((entry) => entry.order === state.activeMatchdayOrder)) {
          return;
        }
        const indexByDate = resolveMatchdayIndexByDate(state.date, matchdays);
        if (indexByDate !== -1) {
          state.activeMatchdayOrder = matchdays[indexByDate].order;
          return;
        }
        const closestIndex = findClosestMatchdayIndex(state.date, matchdays);
        if (closestIndex !== -1) {
          state.activeMatchdayOrder = matchdays[closestIndex].order;
          return;
        }
        state.activeMatchdayOrder = matchdays[0].order;
      }

      function buildMatchdayMetadata(matches) {
        if (!Array.isArray(matches)) {
          return [];
        }
        const grouped = new Map();
        matches.forEach((match) => {
          const group = match?.group || match?.Group;
          const rawOrder = group?.groupOrderID ?? group?.GroupOrderID;
          const order = Number.parseInt(rawOrder, 10);
          if (!Number.isFinite(order)) {
            return;
          }
          const label = group?.groupName || group?.GroupName || order + '. Spieltag';
          const isoDate = normalizeToIsoDate(match.matchDateTimeUTC || match.matchDateTime);
          if (!grouped.has(order)) {
            grouped.set(order, {
              order,
              label,
              dates: new Set()
            });
          }
          if (isoDate) {
            grouped.get(order).dates.add(isoDate);
          }
        });

        return Array.from(grouped.values())
          .map((entry) => {
            const dates = Array.from(entry.dates).sort();
            return {
              order: entry.order,
              label: entry.label || entry.order + '. Spieltag',
              primaryDate: dates[0] || null,
              dates
            };
          })
          .filter((entry) => entry.primaryDate)
          .sort((a, b) => a.order - b.order);
      }

      function normalizeToIsoDate(value) {
        if (!value) {
          return null;
        }
        if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
          return value;
        }
        const parsed = new Date(value);
        if (Number.isNaN(parsed.getTime())) {
          return null;
        }
        return parsed.toISOString().slice(0, 10);
      }

      function formatDateForLocale(isoDate) {
        if (!isoDate) {
          return '';
        }
        const parsed = new Date(`${isoDate}T12:00:00Z`);
        if (Number.isNaN(parsed.getTime())) {
          return isoDate;
        }
        return parsed.toLocaleDateString('de-DE', {
          weekday: 'short',
          day: '2-digit',
          month: '2-digit',
          year: 'numeric'
        });
      }

      function populateLeagueOptions() {
        DOM.leagueSelect.innerHTML = '';

        if (state.sport === 'football') {
          DOM.leagueControl.classList.remove('hidden');
          DOM.leagueSelect.disabled = false;
          FOOTBALL_LEAGUES.forEach((league) => {
            const option = document.createElement('option');
            option.value = league.id;
            option.textContent = league.label;
            if (league.id === state.league) {
              option.selected = true;
            }
            DOM.leagueSelect.appendChild(option);
          });
          if (!state.league) {
            state.league = FOOTBALL_LEAGUES[0].id;
          }
        } else {
          DOM.leagueControl.classList.add('hidden');
          DOM.leagueSelect.disabled = true;
        }
      }

      async function requestRefresh(explicit) {
        setStatus(explicit ? 'Lade Live-Daten …' : 'Aktualisiere …', 'info');
        state.fetchInFlight = true;
        state.lastFetchStart = Date.now();

        try {
          if (state.sport === 'football') {
            await loadFootball();
          } else {
            await loadTennis();
          }
          const postLevel = DOM.statusBox.dataset.level;
          if (postLevel === 'info') {
            setStatus('Letzte Aktualisierung: ' + new Date().toLocaleTimeString('de-DE', {
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit'
            }), 'info');
          }
        } catch (error) {
          console.error(error);
          setStatus('Fehler beim Laden: ' + error.message, 'error');
        } finally {
          state.fetchInFlight = false;
        }
      }

      async function loadFootball() {
        const leagueConfig = FOOTBALL_LEAGUES.find((league) => league.id === state.league) || FOOTBALL_LEAGUES[0];
        const season = deriveFootballSeason(state.date);
        const shortcuts = [leagueConfig.shortcut, ...(leagueConfig.alternatives || [])].filter(Boolean);

        let rawData = [];
        let lastError = null;

        for (const shortcut of shortcuts) {
          try {
            rawData = await fetchJsonWithCache(`${OPENLIGA_BASE}/getmatchdata/${shortcut}/${season}`, { cacheKey: `matches:${shortcut}:${season}`, ttl: 60000 });
            if (Array.isArray(rawData) && rawData.length > 0) {
              break;
            }
          } catch (error) {
            lastError = error;
          }
        }

        if (!Array.isArray(rawData) || rawData.length === 0) {
          const detail = lastError ? ` (${lastError.message})` : '';
          renderMatches([], 'Keine Spiele für den ausgewählten Tag gefunden.');
          renderTable([], { emptyMessage: 'Keine Tabellen-Daten hinterlegt.' });
          setStatus('Keine Daten für ' + leagueConfig.label + ' verfügbar' + detail + '.', 'warning');
          return;
        }

        if (Array.isArray(rawData)) {
          const metadata = buildMatchdayMetadata(rawData);
          state.matchdays = metadata;
          ensureActiveMatchday(metadata);
          updateMatchdayDisplay();
        } else {
          state.matchdays = [];
          state.activeMatchdayOrder = null;
          updateMatchdayDisplay();
        }

        const matches = rawData
          .filter((match) => matchBelongsToActiveMatchday(match))
          .map((match) => ({
            id: match.matchId || match.matchID,
            time: formatTime(match.matchDateTimeUTC || match.matchDateTime),
            home: match.team1?.teamName || match.Team1?.TeamName || 'Heim',
            away: match.team2?.teamName || match.Team2?.TeamName || 'Gast',
            score: formatScore(match.matchResults || match.MatchResults),
            status: deriveMatchStatus(match)
          }));

        renderMatches(matches, 'Keine Spiele für den ausgewählten Tag gefunden.');

        const allMatchesPlanned = matches.length > 0 && matches.every((entry) => entry.status === 'Geplant');

        if (leagueConfig.table) {
          let matchday = deriveMatchday(rawData, matches);
          if (!Number.isFinite(matchday) && Number.isFinite(state.activeMatchdayOrder)) {
            matchday = state.activeMatchdayOrder;
          }
          if (!Number.isFinite(matchday)) {
            matchday = await fetchCurrentGroup(leagueConfig.shortcut, season);
          }
          const tableResult = await resolveFootballTable(leagueConfig.shortcut, season, matchday);
          if (tableResult.rows.length) {
            renderTable(tableResult.rows);
            if (tableResult.notice) {
              setStatus(tableResult.notice, 'warning');
            }
          } else {
            const emptyMessage = allMatchesPlanned
              ? 'Tabelle wird nach Abschluss des Spieltags aktualisiert.'
              : 'Keine Tabellen-Daten für diesen Spieltag verfügbar.';
            renderTable([], { emptyMessage });
            if (tableResult.error?.status === 404 || allMatchesPlanned) {
              setStatus('Für diesen Spieltag liegt noch keine Tabelle vor.', 'info');
            } else if (tableResult.error) {
              setStatus('Tabelle konnte nicht geladen werden: ' + tableResult.error.message, 'warning');
            } else {
              setStatus('Tabelle konnte nicht bestimmt werden (kein Spieltag gefunden).', 'warning');
            }
          }
        } else {
          renderTable([], { emptyMessage: 'Keine Tabellen-Daten hinterlegt.' });
        }
      }

      async function loadTennis() {
        const date = state.date;
        const aggregated = new Map();
        let lastError = null;

        for (const source of TENNIS_SOURCES) {
          try {
            const scoreboard = await fetchEspnTennisScoreboard(source.tour, date);
            const matches = extractEspnTennisMatches(scoreboard, date, { requireMajor: source.requireMajor, tour: source.tour });
            matches.forEach((match) => {
              const key = `${source.tour}:${match.id}`;
              if (!aggregated.has(key)) {
                aggregated.set(key, match);
              }
            });
          } catch (error) {
            lastError = error;
          }
        }

        let matches = Array.from(aggregated.values())
          .sort((a, b) => (a.timeRaw || '').localeCompare(b.timeRaw || '') || a.home.localeCompare(b.home));

        if (!matches.length) {
          matches = buildDemoMatches('Tennis', TENNIS_SCOPE_LABEL, date);
          const detail = lastError ? ` (Quelle: ${lastError.message})` : '';
          setStatus('Keine aktuellen Tennis-Daten gefunden – zeige Demo-Ergebnisse' + detail, 'warning');
        } else if (lastError) {
          setStatus('Teilweise Tennis-Daten geladen – Fallback aktiv (' + lastError.message + ')', 'warning');
        }

        renderMatches(matches, 'Keine Tennisbegegnungen für den gewählten Tag gefunden.');
        hideTable();
      }


      async function fetchEspnTennisScoreboard(tour, isoDate) {
        const sanitizedTour = tour || 'atp';
        const compactDate = (isoDate || '').replace(/-/g, '');
        if (!compactDate || compactDate.length !== 8) {
          throw new Error('Ungültiges Datum für Tennis-Abruf');
        }
        const url = `https://site.api.espn.com/apis/site/v2/sports/tennis/${sanitizedTour}/scoreboard?dates=${compactDate}`;
        const cacheKey = `espn-tennis:${sanitizedTour}:${compactDate}`;
        return fetchJsonWithCache(url, { cacheKey, ttl: 60000 });
      }

      function extractEspnTennisMatches(scoreboard, isoDate, { requireMajor, tour }) {
        if (!scoreboard || !Array.isArray(scoreboard.events)) {
          return [];
        }
        const targetDate = normalizeToIsoDate(isoDate);
        const matches = [];
        scoreboard.events.forEach((event) => {
          if (requireMajor && !event?.major) {
            return;
          }
          const groupings = Array.isArray(event?.groupings) ? event.groupings : [];
          groupings.forEach((grouping) => {
            const competitions = Array.isArray(grouping?.competitions) ? grouping.competitions : [];
            competitions.forEach((competition) => {
              const kickoffIso = normalizeToIsoDate(competition?.date || competition?.startDate);
              if (targetDate && kickoffIso !== targetDate) {
                return;
              }
              const competitors = Array.isArray(competition?.competitors) ? competition.competitors : [];
              const home = competitors.find((entry) => entry.homeAway === 'home') || competitors[0];
              const away = competitors.find((entry) => entry.homeAway === 'away') || competitors[1];
              if (!home || !away) {
                return;
              }
              const id = competition.id || competition.uid || `${tour || 'atp'}-${competition?.date || ''}-${competitors.length}`;
              matches.push({
                id,
                timeRaw: competition?.date || competition?.startDate || '',
                time: formatTime(competition?.date || competition?.startDate),
                home: formatEspnTennisCompetitor(home),
                away: formatEspnTennisCompetitor(away),
                score: formatEspnTennisScore(home, away, competition),
                status: mapEspnTennisStatus(competition)
              });
            });
          });
        });
        return matches;
      }

      function formatEspnTennisCompetitor(entry) {
        if (!entry) {
          return 'Unbekannt';
        }
        if (entry.roster?.displayName) {
          return entry.roster.displayName;
        }
        if (Array.isArray(entry.roster?.athletes) && entry.roster.athletes.length) {
          return entry.roster.athletes.map((athlete) => athlete.shortName || athlete.displayName || 'Spieler').join(' / ');
        }
        if (entry.athlete?.displayName) {
          return entry.athlete.displayName;
        }
        if (entry.team?.displayName) {
          return entry.team.displayName;
        }
        return entry.displayName || entry.shortName || 'Spieler';
      }

      function formatEspnTennisScore(home, away, competition) {
        const homeSets = Array.isArray(home?.linescores) ? home.linescores : [];
        const awaySets = Array.isArray(away?.linescores) ? away.linescores : [];
        const maxSets = Math.max(homeSets.length, awaySets.length);
        const sets = [];
        for (let index = 0; index < maxSets; index += 1) {
          const homeValue = homeSets[index]?.value;
          const awayValue = awaySets[index]?.value;
          if (homeValue == null && awayValue == null) {
            continue;
          }
          const formattedHome = Number.isFinite(homeValue) ? Math.trunc(homeValue) : '-';
          const formattedAway = Number.isFinite(awayValue) ? Math.trunc(awayValue) : '-';
          let display = `${formattedHome}:${formattedAway}`;
          const tieHome = homeSets[index]?.tiebreak;
          const tieAway = awaySets[index]?.tiebreak;
          if (Number.isFinite(tieHome) || Number.isFinite(tieAway)) {
            display += ` (${Number.isFinite(tieHome) ? tieHome : '-'}:${Number.isFinite(tieAway) ? tieAway : '-'})`;
          }
          sets.push(display);
        }
        if (sets.length) {
          return sets.join(' · ');
        }
        const detail = competition?.status?.type?.detail || competition?.status?.type?.shortDetail;
        if (detail && detail !== 'TBD') {
          return detail;
        }
        return '-- : --';
      }

      function mapEspnTennisStatus(competition) {
        const state = competition?.status?.type?.state;
        const name = competition?.status?.type?.name;
        if (state === 'in') {
          return 'Live';
        }
        if (state === 'post') {
          if (name === 'STATUS_RETIRED') {
            return 'Aufgegeben';
          }
          if (name === 'STATUS_CANCELLED' || name === 'STATUS_WALKOVER') {
            return 'Abgebrochen';
          }
          return 'Beendet';
        }
        if (state === 'suspended' || name === 'STATUS_DELAYED') {
          return 'Unterbrochen';
        }
        return 'Geplant';
      }

      function buildDemoMatches(sportLabel, competitionLabel, isoDate) {
        const baseDate = normalizeToIsoDate(isoDate) || new Date().toISOString().slice(0, 10);
        const label = competitionLabel ? `${sportLabel} · ${competitionLabel}` : sportLabel;
        const createEntry = (offsetHours, home, away, score) => {
          const date = new Date(`${baseDate}T00:00:00Z`);
          date.setUTCHours(date.getUTCHours() + offsetHours);
          return {
            id: `${sportLabel.toLowerCase()}-demo-${offsetHours}-${home.replace(/\s+/g, '-')}`,
            time: date.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }),
            timeRaw: date.toISOString(),
            home,
            away,
            score,
            status: 'Simulation'
          };
        };
        return [
          createEntry(12, `${label} Team A`, `${label} Team B`, '2 : 1'),
          createEntry(14, `${label} Team C`, `${label} Team D`, '1 : 1'),
          createEntry(16, `${label} Team E`, `${label} Team F`, '3 : 2')
        ];
      }

      function renderMatches(matches, emptyMessage) {
        DOM.resultsBody.innerHTML = '';
        if (!matches || !matches.length) {
          DOM.noResults.textContent = emptyMessage || 'Keine Ergebnisse für den gewählten Tag gefunden.';
          DOM.noResults.classList.remove('hidden');
          return;
        }
        DOM.noResults.classList.add('hidden');

        matches
          .sort((a, b) => {
            const first = a.timeRaw || '';
            const second = b.timeRaw || '';
            const rawCompare = first.localeCompare(second);
            if (rawCompare !== 0) {
              return rawCompare;
            }
            const timeCompare = (a.time || '').localeCompare(b.time || '');
            if (timeCompare !== 0) {
              return timeCompare;
            }
            return a.home.localeCompare(b.home);
          })
          .forEach((match) => {
            const row = document.createElement('tr');
            row.innerHTML = `
              <td class="col-home">
                <span class="team-name">${escapeHtml(match.home)}</span>
              </td>
              <td class="col-away">
                <span class="team-name">${escapeHtml(match.away)}</span>
              </td>
              <td class="score col-score">${escapeHtml(match.score)}</td>
            `;
            DOM.resultsBody.appendChild(row);
          });
      }

      function hideTable() {
        DOM.tableSection.classList.add('hidden');
        DOM.standingsBody.innerHTML = '';
      }

      function renderTable(rows, { emptyMessage = 'Keine Tabellen-Daten verfügbar.' } = {}) {
        DOM.tableSection.classList.remove('hidden');
        DOM.standingsBody.innerHTML = '';

        if (!rows || !rows.length) {
          const emptyRow = document.createElement('tr');
          emptyRow.className = 'standings-empty';
          emptyRow.innerHTML = `<td colspan="7">${escapeHtml(emptyMessage)}</td>`;
          DOM.standingsBody.appendChild(emptyRow);
          return;
        }

        rows.forEach((entry) => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${entry.rank ?? '-'}</td>
            <td>${escapeHtml(entry.team ?? '')}</td>
            <td>${entry.wins ?? '-'}</td>
            <td>${entry.draws ?? '-'}</td>
            <td>${entry.losses ?? '-'}</td>
            <td>${escapeHtml(entry.goals ?? '')}</td>
            <td>${entry.points ?? '-'}</td>
          `;
          DOM.standingsBody.appendChild(tr);
        });
      }

      function setStatus(message, level) {
        DOM.statusBox.dataset.level = level || 'info';
        DOM.statusBox.textContent = message;
      }

      function matchesSelectedDate(dateValue, selectedDate) {
        if (!dateValue || !selectedDate) {
          return false;
        }
        const target = typeof dateValue === 'number' ? new Date(dateValue) : new Date(dateValue);
        const normalized = target.toISOString().slice(0, 10);
        return normalized === selectedDate;
      }

      function matchBelongsToActiveMatchday(match) {
        if (!match) {
          return false;
        }
        const group = match.group || match.Group;
        const rawOrder = group?.groupOrderID ?? group?.GroupOrderID;
        const matchdayOrder = rawOrder != null ? Number.parseInt(rawOrder, 10) : NaN;
        if (typeof state.activeMatchdayOrder === 'number' && Number.isFinite(state.activeMatchdayOrder) && Number.isFinite(matchdayOrder)) {
          return matchdayOrder === state.activeMatchdayOrder;
        }
        return matchesSelectedDate(match.matchDateTimeUTC || match.matchDateTime, state.date);
      }

      function deriveFootballSeason(dateStr) {
        const date = new Date(dateStr + 'T00:00:00Z');
        const year = date.getUTCFullYear();
        const month = date.getUTCMonth() + 1;
        return month >= 7 ? year : year - 1;
      }

      function deriveMatchStatus(match) {
        if (match.matchIsFinished || match.MatchIsFinished) {
          return 'Beendet';
        }
        const start = Date.parse(match.matchDateTimeUTC || match.matchDateTime);
        if (!Number.isNaN(start) && Date.now() >= start) {
          return 'Live';
        }
        return 'Geplant';
      }

      function formatTime(value, isEpochSeconds = false) {
        if (!value) {
          return '--:--';
        }
        const date = isEpochSeconds ? new Date(value) : new Date(value);
        if (Number.isNaN(date.getTime())) {
          return '--:--';
        }
        return date.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
      }

      function formatScore(results) {
        if (!results || !results.length) {
          return '-- : --';
        }
        const final = results.find((entry) => entry.resultTypeID === 2 || entry.resultTypeId === 2) || results[results.length - 1];
        if (!final) {
          return '-- : --';
        }
        const home = final.pointsTeam1 ?? final.PointsTeam1 ?? '-';
        const away = final.pointsTeam2 ?? final.PointsTeam2 ?? '-';
        return `${home} : ${away}`;
      }

      function deriveMatchday(rawData, matchesOfDay) {
        const reference = matchesOfDay?.[0];
        if (reference && reference.id) {
          const original = rawData.find((match) => (match.matchId || match.matchID) === reference.id);
          return original?.group?.groupOrderID || original?.Group?.GroupOrderID;
        }
        const fallback = rawData.find((match) => match.group?.groupOrderID || match.Group?.GroupOrderID);
        return fallback?.group?.groupOrderID || fallback?.Group?.GroupOrderID || null;
      }

      async function fetchCurrentGroup(shortcut, season) {
        try {
          const group = await fetchJsonWithCache(`${OPENLIGA_BASE}/getcurrentgroup/${shortcut}/${season}`, { cacheKey: `group:${shortcut}:${season}`, ttl: 300000 });
          return group?.groupOrderID || group?.GroupOrderID || null;
        } catch (error) {
          console.warn('getcurrentgroup failed', error);
          return null;
        }
      }

      async function resolveFootballTable(shortcut, season, matchday) {
        const attempts = [];
        const seen = new Set();

        const pushAttempt = (targetSeason, targetMatchday) => {
          const key = `${targetSeason}:${targetMatchday ?? 'full'}`;
          if (seen.has(key)) {
            return;
          }
          seen.add(key);
          attempts.push({ season: targetSeason, matchday: targetMatchday });
        };

        if (season) {
          if (matchday) {
            pushAttempt(season, matchday);
            if (matchday > 1) {
              pushAttempt(season, matchday - 1);
            }
          }
          pushAttempt(season, null);
        }
        if (season) {
          pushAttempt(season - 1, null);
        }

        let lastError = null;
        for (const attempt of attempts) {
          try {
            const suffix = attempt.matchday ? `/${attempt.matchday}` : '';
            const data = await fetchJsonWithCache(`${OPENLIGA_BASE}/getbltable/${shortcut}/${attempt.season}${suffix}`, {
              cacheKey: `table:${shortcut}:${attempt.season}:${attempt.matchday ?? 'full'}`,
              ttl: 300000
            });
            if (Array.isArray(data) && data.length) {
              const formatted = formatTable(data);
              const notice = attempt.season !== season
                ? `Tabelle der Saison ${attempt.season}/${String((attempt.season + 1) % 100).padStart(2, '0')} als Fallback.`
                : null;
              return { rows: formatted, notice };
            }
          } catch (error) {
            lastError = error;
          }
        }

        return { rows: [], error: lastError };
      }

      async function fetchJson(url, { timeout = FETCH_TIMEOUT_MS } = {}) {
        const text = await fetchText(url, { timeout, headers: { Accept: 'application/json,text/plain' } });
        if (!text) {
          return null;
        }
        const trimmed = text.trim();
        try {
          return JSON.parse(trimmed);
        } catch (error) {
          const looksLikeBase64 = url?.endsWith('.base64.txt') || /^[A-Za-z0-9+/=\s]+$/.test(trimmed);
          if (looksLikeBase64) {
            const decoded = decodeBase64Json(trimmed);
            if (decoded != null) {
              return decoded;
            }
          }
          throw error;
        }
      }

      async function fetchJsonWithCache(url, { cacheKey, ttl = 60000 } = {}) {
        const cached = cacheKey ? getCacheEntry(cacheKey, ttl) : null;
        if (cached != null) {
          return cached;
        }
        const value = await fetchJson(url);
        if (cacheKey) {
          setCacheEntry(cacheKey, value);
        }
        return value;
      }

      function formatTable(entries) {
        if (!Array.isArray(entries)) {
          return [];
        }
        return entries.map((entry, index) => ({
          rank: entry.rank ?? entry.Rank ?? index + 1,
          team: entry.teamName ?? entry.TeamName ?? entry.team?.teamName ?? 'Team',
          wins: entry.won ?? entry.Won,
          draws: entry.draw ?? entry.Draw,
          losses: entry.lost ?? entry.Lost,
          goals: `${entry.goals ?? entry.Goals ?? 0}:${entry.opponentGoals ?? entry.OpponentGoals ?? 0}`,
          points: entry.points ?? entry.Points
        }));
      }

      function escapeHtml(value) {
        return String(value ?? '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }
    })();
  </script>
</body>
</html>
