<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Live Ergebnisdienst</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f172a;
      --bg-alt: #111c32;
      --card: #1e293b;
      --border: #293549;
      --accent: #60a5fa;
      --accent-soft: rgba(96, 165, 250, 0.12);
      --text: #e2e8f0;
      --muted: #94a3b8;
      --danger: #f87171;
      --warning: #fbbf24;
      font-family: "Inter", "SF Pro Text", "Segoe UI", Roboto, Arial, sans-serif;
      font-size: 15px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: linear-gradient(160deg, var(--bg) 0%, var(--bg-alt) 100%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1.8rem 1.2rem 0.8rem;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.6rem, 2.5vw, 2.2rem);
      font-weight: 700;
    }

    header p {
      margin: 0.4rem 0 0;
      font-size: 0.8rem;
      color: var(--muted);
    }

    main {
      width: min(980px, 92vw);
      margin: 0 auto 1.4rem;
      flex: 1 0 auto;
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }

    .control-panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 0.85rem clamp(0.8rem, 2.2vw, 1.4rem);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 0.75rem clamp(0.5rem, 1.5vw, 1rem);
      box-shadow: 0 22px 48px -28px rgba(6, 10, 20, 0.65);
    }

    .control {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 600;
      color: var(--muted);
    }

    select,
    input[type="date"] {
      appearance: none;
      border: 1px solid var(--border);
      border-radius: 0.6rem;
      padding: 0.5rem 0.7rem;
      font-size: 0.9rem;
      color: var(--text);
      background: rgba(15, 23, 42, 0.7);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    select:focus,
    input[type="date"]:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.25);
    }

    .matchday-group {
      display: flex;
      width: 100%;
    }

    .matchday-select {
      border: 1px solid var(--border);
      border-radius: 0.6rem;
      padding: 0.5rem 0.7rem;
      font-size: 0.9rem;
      color: var(--text);
      background: rgba(15, 23, 42, 0.7);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      text-align: center;
      appearance: none;
      -webkit-appearance: none;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      width: 100%;
    }

    .matchday-select:focus-visible {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.25);
    }

    #status-box {
      padding: 0.65rem 0.9rem;
      border-radius: 0.7rem;
      font-size: 0.82rem;
      background: var(--accent-soft);
      color: var(--accent);
      border: 1px solid rgba(96, 165, 250, 0.32);
      display: flex;
      align-items: center;
      gap: 0.45rem;
      min-height: 2.6rem;
    }

    #status-box[data-level="error"] {
      background: rgba(248, 113, 113, 0.12);
      color: var(--danger);
      border-color: rgba(248, 113, 113, 0.28);
    }

    #status-box[data-level="warning"] {
      background: rgba(251, 191, 36, 0.14);
      color: var(--warning);
      border-color: rgba(251, 191, 36, 0.28);
    }

    .content-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: clamp(0.75rem, 2vw, 1.2rem);
      box-shadow: 0 24px 52px -32px rgba(5, 10, 22, 0.7);
    }

    .content-card h2 {
      margin: 0 0 1rem;
      font-size: 1.1rem;
    }

    .table-wrapper {
      overflow-x: auto;
      border-radius: 0.85rem;
      border: 1px solid var(--border);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      background: var(--card);
    }

    thead {
      background: rgba(148, 163, 184, 0.08);
    }

    th,
    td {
      padding: 0.55rem 0.75rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.12);
      text-align: left;
      white-space: nowrap;
    }

    tbody tr:hover {
      background: rgba(148, 163, 184, 0.12);
    }

    #standings-table tr.standings-empty td {
      text-align: center;
      font-style: italic;
      color: var(--muted);
      padding: 0.85rem;
    }

    td.score {
      font-weight: 600;
      font-size: 0.95rem;
    }

    .empty-state {
      margin: 1.4rem 0 0;
      text-align: center;
      padding: 1.6rem;
      border-radius: 0.75rem;
      background: rgba(148, 163, 184, 0.08);
      border: 1px dashed var(--border);
      color: var(--muted);
    }

    .hidden {
      display: none !important;
    }

    footer {
      text-align: center;
      padding: 1.1rem 0.8rem 1.6rem;
      font-size: 0.72rem;
      color: var(--muted);
    }

    footer a {
      color: var(--accent);
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }

    @media (max-width: 720px) {
      header {
        padding-top: 1.4rem;
      }

      .content-card,
      .control-panel {
        border-radius: 0.65rem;
      }

      th,
      td {
        padding: 0.5rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Live Ergebnisdienst</h1>
  <p>Aktuelle Ergebnisse für Fußball und Tennis – gefiltert nach Datum und Wettbewerb.</p>
  </header>

  <main>
    <section class="control-panel" aria-label="Filter">
      <div class="control">
        <label for="sport-select">Sportart</label>
        <select id="sport-select">
          <option value="football">Fußball</option>
          <option value="tennis">Tennis</option>
        </select>
      </div>

      <div class="control" id="league-control">
        <label for="league-select">Wettbewerb</label>
        <select id="league-select"></select>
      </div>

      <div class="control">
        <label for="matchday-current">Spieltag</label>
        <div class="matchday-group" id="matchday-group" role="group" aria-label="Spieltag auswählen">
          <select id="matchday-current" class="matchday-select" aria-label="Aktueller Spieltag"></select>
        </div>
      </div>
    </section>

    <div id="status-box" role="status" aria-live="polite">Initialisiere Live-Daten …</div>

    <section id="results-section" class="content-card" aria-live="polite">
      <h2>Ergebnisse</h2>
      <div class="table-wrapper"
           id="results-wrapper">
        <table id="results-table">
          <thead>
            <tr>
              <th>Heim</th>
              <th>Gast</th>
              <th>Ergebnis</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <p class="empty-state hidden" id="no-results">Keine Ergebnisse für den gewählten Tag gefunden.</p>
    </section>

    <section id="table-section" class="content-card hidden">
      <h2>Tabellenstand</h2>
      <div class="table-wrapper">
        <table id="standings-table">
          <thead>
            <tr>
              <th>Rang</th>
              <th>Team</th>
              <th>S</th>
              <th>U</th>
              <th>N</th>
              <th>Tore</th>
              <th>Diff</th>
              <th>Pkt</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
  </main>

  <footer>
    <span>Automatische Aktualisierung alle 5&nbsp;ms (netzwerkschonender Abruf mit Drosselung). Bei ausbleibenden Live-Daten wird eine Simulation angezeigt.</span>
  </footer>

  <script>
    (() => {
      const POLL_INTERVAL_MS = 5; // UI loop cadence (requirement)
      const MIN_FETCH_INTERVAL_MS = 5000; // throttle real network calls (protect remote APIs)
      const FETCH_TIMEOUT_MS = 12000;
      const OPENLIGA_BASE = 'https://api.openligadb.de';

      const DOM = {
        sportSelect: document.getElementById('sport-select'),
        leagueControl: document.getElementById('league-control'),
        leagueSelect: document.getElementById('league-select'),
        matchdayGroup: document.getElementById('matchday-group'),
        matchdayCurrent: document.getElementById('matchday-current'),
        statusBox: document.getElementById('status-box'),
        resultsTable: document.getElementById('results-table'),
        resultsBody: document.querySelector('#results-table tbody'),
        noResults: document.getElementById('no-results'),
        tableSection: document.getElementById('table-section'),
        standingsBody: document.querySelector('#standings-table tbody')
      };

      const today = new Date();
      const defaultDate = today.toISOString().slice(0, 10);

      const state = {
        sport: 'football',
        league: null,
        tennisCategory: 'all',
        date: defaultDate,
        matchdays: [],
        activeMatchdayOrder: null,
        timerId: null,
        lastFetchStart: 0,
        fetchInFlight: false,
        lastError: null
      };

      const cache = new Map();

      function decodeBase64Json(base64Text) {
        if (!base64Text) {
          return null;
        }
        try {
          const normalized = base64Text.replace(/\s+/g, '');
          const binary = atob(normalized);
          const bytes = Uint8Array.from(binary, (char) => char.charCodeAt(0));
          const decoded = new TextDecoder('utf-8').decode(bytes);
          return JSON.parse(decoded);
        } catch (error) {
          console.warn('Regionalliga Base64-Dekodierung fehlgeschlagen', error);
          return null;
        }
      }

      async function fetchText(url, { timeout = FETCH_TIMEOUT_MS, headers } = {}) {
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), timeout);
        try {
          const response = await fetch(url, { signal: controller.signal, headers });
          if (!response.ok) {
            const error = new Error(`${response.status} ${response.statusText}`.trim());
            error.status = response.status;
            error.url = url;
            throw error;
          }
          return await response.text();
        } finally {
          clearTimeout(timer);
        }
      }

      async function fetchTextWithCache(url, { cacheKey, ttl = 60000, headers } = {}) {
        if (cacheKey && cache.has(cacheKey)) {
          const entry = cache.get(cacheKey);
          if (Date.now() - entry.timestamp < ttl) {
            return entry.value;
          }
        }
        const value = await fetchText(url, { headers });
        if (cacheKey) {
          cache.set(cacheKey, { value, timestamp: Date.now() });
        }
        return value;
      }
      const FOOTBALL_LEAGUES = [
        {
          id: 'bl1',
          label: '1. Liga',
          shortcut: 'bl1',
          table: true
        },
        {
          id: 'bl2',
          label: '2. Liga',
          shortcut: 'bl2',
          table: true
        },
        {
          id: 'bl3',
          label: '3. Liga',
          shortcut: 'bl3',
          table: true
        },
        {
          id: 'regionalliga-nord',
          label: 'Reg. Nord',
          shortcut: 'rlnord',
          alternatives: ['rl-nord', 'rlno', 'relino', 'rlnord17'],
          table: true
        }
      ];

      const REGIONALLIGA_NORD_FEED = {
        matchesUrl: [
          './data/regionalliga-nord-matches.json',
          './data/regionalliga-nord-matches.base64.txt',
          './public/data/regionalliga-nord-matches.json',
          './public/data/regionalliga-nord-matches.base64.txt',
          './regionalliga-nord-matches.json',
          './regionalliga-nord-matches.base64.txt'
        ],
        tableUrl: [
          './data/regionalliga-nord-table.json',
          './public/data/regionalliga-nord-table.json',
          './regionalliga-nord-table.json'
        ],
        cacheBust: '20251117-base64'
      };

      /* Legacy inline fallback kept for reference
    const REGIONALLIGA_NORD_INLINE = (() => {
        const base64Matches = `
ewogICJsYXN0VXBkYXRlZCI6ICIyMDI1LTExLTE2VDA5OjAwOjAwKzAxOjAwIiwKICAic291cmNlIjogIlJlZ2lvbmFsbGlnYSBOb3JkIOKAkyBzeW50aGV0aXNjaGVyIERvcHBlbHJ1bmRlbi1TcGllbHBsYW4gKDE4IFRlYW1zLCAzNCBTcGllbHRhZ2UpIiwKICAibWF0Y2hlcyI6IFsKICAgIHsKICAgICAgImlkIjogIlJMTi0yMDI1LU1EMDEtMDEiLAogICAgICAibWF0Y2hkYXkiOiAxLAogICAgICAia2lja29mZiI6ICIyMDI1LTA4LTAyVDE0OjAwOjAwKzAyOjAwIiwKICAgICAgImhvbWUiOiAiV2VpY2hlIEZsZW5zYnVyZyAwOCIsCiAgICAgICJhd2F5IjogIldlcmRlciBCcmVtZW4gSUkiLAogICAgICAic2NvcmUiOiAiLTotIiwKICAgICAgInN0YXR1cyI6ICJHZXBsYW50IgogICAgfSwKICAgIHsKICAgICAgImlkIjogIlJMTi0yMDI1LU1EMDEtMDIiLAogICAgICAibWF0Y2hkYXkiOiAxLAogICAgICAia2lja29mZiI6ICIyMDI1LTA4LTAyVDE1OjAwOjAwKzAyOjAwIiwKICAgICAgImhvbWUiOiAiRWludHJhY2h0IE5vcmRlcnN0ZWR0IiwKICAgICAgImF3YXkiOiAiU1YgRHJvY2h0ZXJzZW4vQXNzZWwiLAogICAgICAic2NvcmUiOiAiLTotIiwKICAgICAgInN0YXR1cyI6ICJHZXBsYW50IgogICAgfSwKICAgIHsKICAgICAgImlkIjogIlJMTi0yMDI1LU1EMDEtMDMiLAogICAgICAibWF0Y2hkYXkiOiAxLAogICAgICAia2lja29mZiI6ICIyMDI1LTA4LTAyVDE2OjAwOjAwKzAyOjAwIiwKICAgICAgImhvbWUiOiAiSGFtYnVyZ2VyIFNWIElJIiwKICAgICAgImF3YXkiOiAiVGV1dG9uaWEgT3R0ZW5zZW4iLAogICAgICAic2NvcmUiOiAiLTotIiwKICAgICAgInN0YXR1cyI6ICJHZXBsYW50IgogICAgfSwKICAgIHsKICAgICAgImlkIjogIlJMTi0yMDI1LU1EMDEtMDQiLAogICAgICAibWF0Y2hkYXkiOiAxLAogICAgICAia2lja29mZiI6ICIyMDI1LTA4LTAyVDE3OjAwOjAwKzAyOjAwIiwKICAgICAgImhvbWUiOiAiU1NWIEplZGRlbG9oIiwKICAgICAgImF3YXkiOiAiVmZCIE9sZGVuYnVyZyIsCiAgICAgICJzY29yZSI6ICItOi0iLAogICAgICAic3RhdHVzIjogIkdlcGxhbnQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiUkxOLTIwMjUtTUQwMS0wNSIsCiAgICAgICJtYXRjaGRheSI6IDEsCiAgICAgICJraWNrb2ZmIjogIjIwMjUtMDgtMDJUMTg6MDA6MDArMDI6MDAiLAogICAgICAiaG9tZSI6ICJWZkIgTMO8YmVjayIsCiAgICAgICJhd2F5IjogIkFsdG9uYSA5MyIsCiAgICAgICJzY29yZSI6ICItOi0iLAogICAgICAic3RhdHVzIjogIkdlcGxhbnQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiUkxOLTIwMjUtTUQwMS0wNiIsCiAgICAgICJtYXRjaGRheSI6IDEsCiAgICAgICJraWNrb2ZmIjogIjIwMjUtMDgtMDJUMTk6MDA6MDArMDI6MDAiLAogICAgICAiaG9tZSI6ICJQaMO2bml4IEzDvGJlY2siLAogICAgICAiYXdheSI6ICJTViBNZXBwZW4iLAogICAgICAic2NvcmUiOiAiLTotIiwKICAgICAgInN0YXR1cyI6ICJHZXBsYW50IgogICAgfSwKICAgIHsKICAgICAgImlkIjogIlJMTi0yMDI1LU1EMDEtMDciLAogICAgICAibWF0Y2hkYXkiOiAxLAogICAgICAia2lja29mZiI6ICIyMDI1LTA4LTAyVDIwOjAwOjAwKzAyOjAwIiwKICAgICAgImhvbWUiOiAiRWltc2LDvHR0ZWxlciBUViIsCiAgICAgICJhd2F5IjogIkhhbm5vdmVyIDk2IElJIiwKICAgICAgInNjb3JlIjogIi06LSIsCiAgICAgICJzdGF0dXMiOiAiR2VwbGFudCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJSTE4tMjAyNS1NRDAxLTA4IiwKICAgICAgIm1hdGNoZGF5IjogMSwKICAgICAgImtpY2tvZmYiOiAiMjAyNS0wOC0wMlQyMTowMDowMCswMjowMCIsCiAgICAgICJob21lIjogIkZDIFN0LiBQYXVsaSBJSSIsCiAgICAgICJhd2F5IjogIkJXIExvaG5lIiwKICAgICAgInNjb3JlIjogIi06LSIsCiAgICAgICJzdGF0dXMiOiAiR2VwbGFudCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJSTE4tMjAyNS1NRDAxLTA5IiwKICAgICAgIm1hdGNoZGF5IjogMSwKICAgICAgImtpY2tvZmYiOiAiMjAyNS0wOC0wMlQyMjowMDowMCswMjowMCIsCiAgICAgICJob21lIjogIkhvbHN0ZWluIEtpZWwgSUkiLAogICAgICAiYXdheSI6ICJCcmVtZXIgU1YiLAogICAgICAic2NvcmUiOiAiLTotIiwKICAgICAgInN0YXR1cyI6ICJHZXBsYW50IgogICAgfSwKICAgIHsKICAgICAgImlkIjogIlJMTi0yMDI1LU1EMDItMDEiLAogICAgICAibWF0Y2hkYXkiOiAyLAogICAgICAia2lja29mZiI6ICIyMDI1LTA4LTA5VDE0OjAwOjAwKzAyOjAwIiwKICAgICAgImhvbWUiOiAiU1YgRHJvY2h0ZXJzZW4vQXNzZWwiLAogICAgICAiYXdheSI6ICJXZWljaGUgRmxlbnNidXJnIDA4IiwKICAgICAgInNjb3JlIjogIi06LSIsCiAgICAgICJzdGF0dXMiOiAiR2VwbGFudCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJSTE4tMjAyNS1NRDAyLTAyIiwKICAgICAgIm1hdGNoZGF5IjogMiwKICAgICAgImtpY2tvZmYiOiAiMjAyNS0wOC0wOVQxNTowMDowMCswMjowMCIsCiAgICAgICJob21lIjogIlRldXRvbmlhIE90dGVuc2VuIiwKICAgICAgImF3YXkiOiAiV2VyZGVyIEJyZW1lbiBJSSIsCiAgICAgICJzY29yZSI6ICItOi0iLAogICAgICAic3RhdHVzIjogIkdlcGxhbnQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiUkxOLTIwMjUtTUQwMi0wMyIsCiAgICAgICJtYXRjaGRheSI6IDIsCiAgICAgICJraWNrb2ZmIjogIjIwMjUtMDgtMDlUMTY6MDA6MDArMDI6MDAiLAogICAgICAiaG9tZSI6ICJWZkIgT2xkZW5idXJnIiwKICAgICAgImF3YXkiOiAiRWludHJhY2h0IE5vcmRlcnN0ZWR0IiwKICAgICAgInNjb3JlIjogIi06LSIsCiAgICAgICJzdGF0dXMiOiAiR2VwbGFudCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJSTE4tMjAyNS1NRDAyLTA0IiwKICAgICAgIm1hdGNoZGF5IjogMiwKICAgICAgImtpY2tvZmYiOiAiMjAyNS0wOC0wOVQxNzowMDowMCswMjowMCIsCiAgICAgICJob21lIjogIkFsdG9uYSA5MyIsCiAgICAgICJhd2F5IjogIkhhbWJ1cmdlciBTViBJSSIsCiAgICAgICJzY29yZSI6ICItOi0iLAogICAgICAic3RhdHVzIjogIkdlcGxhbnQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiUkxOLTIwMjUtTUQwMi0wNSIsCiAgICAgICJtYXRjaGRheSI6IDIsCiAgICAgICJraWNrb2ZmIjogIjIwMjUtMDgtMDlUMTg6MDA6MDArMDI6MDAiLAogICAgICAiaG9tZSI6ICJTViBNZXBwZW4iLAogICAgICAiYXdheSI6ICJTU1YgSmVkZGVsb2giLAogICAgICAic2NvcmUiOiAiLTotIiwKICAgICAgInN0YXR1cyI6ICJHZXBsYW50IgogICAgfSwKICAgIHsKICAgICAgImlkIjogIlJMTi0yMDI1LU1EMDItMDYiLAogICAgICAibWF0Y2hkYXkiOiAyLAogICAgICAia2lja29mZiI6ICIyMDI1LTA4LTA5VDE5OjAwOjAwKzAyOjAwIiwKICAgICAgImhvbWUiOiAiSGFubm92ZXIgOTYgSUkiLAogICAgICAiYXdheSI6ICJWZkIgTMO8YmVjayIsCiAgICAgICJzY29yZSI6ICItOi0iLAogICAgICAic3RhdHVzIjogIkdlcGxhbnQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiUkxOLTIwMjUtTUQwMi0wNyIsCiAgICAgICJtYXRjaGRheSI6IDIsCiAgICAgICJraWNrb2ZmIjogIjIwMjUtMDgtMDlUMjA6MDA6MDArMDI6MDAiLAogICAgICAiaG9tZSI6ICJCVyBMb2huZSIsCiAgICAgICJhd2F5IjogIlBow7ZuaXggTMO8YmVjayIsCiAgICAgICJzY29yZSI6ICItOi0iLAogICAgICAic3RhdHVzIjogIkdlcGxhbnQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiUkxOLTIwMjUtTUQwMi0wOCIsCiAgICAgICJtYXRjaGRheSI6IDIsCiAgICAgICJraWNrb2ZmIjogIjIwMjUtMDgtMDlUMjE6MDA6MDArMDI6MDAiLAogICAgICAiaG9tZSI6ICJCcmVtZXIgU1YiLAogICAgICAiYXdheSI6ICJFaW1zYsO8dHRlbGVyIFRWIiwKICAgICAgInNjb3JlIjogIi06LSIsCiAgICAgICJzdGF0dXMiOiAiR2VwbGFudCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJSTE4tMjAyNS1NRDAyLTA5IiwKICAgICAgIm1hdGNoZGF5IjogMiwKICAgICAgImtpY2tvZmYiOiAiMjAyNS0wOC0wOVQyMjowMDowMCswMjowMCIsCiAgICAgICJob21lIjogIkhvbHN0ZWluIEtpZWwgSUkiLAogICAgICAiYXdheSI6ICJGQyBTdC4gUGF1bGkgSUkiLAogICAgICAic2NvcmUiOiAiLTotIiwKICAgICAgInN0YXR1cyI6ICJHZXBsYW50IgogICAgfSwKICAgIHsKICAgICAgImlkIjogIlJMTi0yMDI1LU1EMDMtMDEiLAogICAgICAibWF0Y2hkYXkiOiAzLAogICAgICAia2lja29mZiI6ICIyMDI1LTA4LTE2VDE0OjAwOjAwKzAyOjAwIiwKICAgICAgImhvbWUiOiAiV2VpY2hlIEZsZW5zYnVyZyAwOCIsCiAgICAgICJhd2F5IjogIlRldXRvbmlhIE90dGVuc2VuIiwKICAgICAgInNjb3JlIjogIi06LSIsCiAgICAgICJzdGF0dXMiOiAiR2VwbGFudCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJSTE4tMjAyNS1NRDAzLTAyIiwKICAgICAgIm1hdGNoZGF5IjogMywKICAgICAgImtpY2tvZmYiOiAiMjAyNS0wOC0xNlQxNTowMDowMCswMjowMCIsCiAgICAgICJob21lIjogIlNWIERyb2NodGVyc2VuL0Fzc2VsIiwKICAgICAgImF3YXkiOiAiVmZCIE9sZGVuYnVyZyIsCiAgICAgICJzY29yZSI6ICItOi0iLAogICAgICAic3RhdHVzIjogIkdlcGxhbnQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiUkxOLTIwMjUtTUQwMy0wMyIsCiAgICAgICJtYXRjaGRheSI6IDMsCiAgICAgICJraWNrb2ZmIjogIjIwMjUtMDgtMTZUMTY6MDA6MDArMDI6MDAiLAogICAgICAiaG9tZSI6ICJXZXJkZXIgQnJlbWVuIElJIiwKICAgICAgImF3YXkiOiAiQWx0b25hIDkzIiwKICAgICAgInNjb3JlIjogIi06LSIsCiAgICAgICJzdGF0dXMiOiAiR2VwbGFudCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJSTE4tMjAyNS1NRDAzLTA0IiwKICAgICAgIm1hdGNoZGF5IjogMywKICAgICAgImtpY2tvZmYiOiAiMjAyNS0wOC0xNlQxNzowMDowMCswMjowMCIsCiAgICAgICJob21lIjogIkVpbnRyYWNodCBOb3JkZXJzdGVkdCIsCiAgICAgICJhd2F5IjogIlNWIE1lcHBlbiIsCiAgICAgICJzY29yZSI6ICItOi0iLAogICAgICAic3RhdHVzIjogIkdlcGxhbnQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiUkxOLTIwMjUtTUQwMy0wNSIsCiAgICAgICJtYXRjaGRheSI6IDMsCiAgICAgICJraWNrb2ZmIjogIjIwMjUtMDgtMTZUMTg6MDA6MDArMDI6MDAiLAogICAgICAiaG9tZSI6ICJIYW1idXJnZXIgU1YgSUkiLAogICAgICAiYXdheSI6ICJIYW5ub3ZlciA5NiBJSSIsCiAgICAgICJzY29yZSI6ICItOi0iLAogICAgICAic3RhdHVzIjogIkdlcGxhbnQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiUkxOLTIwMjUtTUQwMy0wNiIsCiAgICAgICJtYXRjaGRheSI6IDMsCiAgICAgICJraWNrb2ZmIjogIjIwMjUtMDgtMTZUMTk6MDA6MDArMDI6MDAiLAogICAgICAiaG9tZSI6ICJTU1YgSmVkZGVsb2giLAogICAgICAiYXdheSI6ICJCVyBMb2huZSIsCiAgICAgICJzY29yZSI6ICItOi0iLAogICAgICAic3RhdHVzIjogIkdlcGxhbnQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiUkxOLTIwMjUtTUQwMy0wNyIsCiAgICAgICJtYXRjaGRheSI6IDMsCiAgICAgICJraWNrb2ZmIjogIjIwMjUtMDgtMTZUMjA6MDA6MDArMDI6MDAiLAogICAgICAiaG9tZSI6ICJWZkIgTMO8YmVjayIsCiAgICAgICJhd2F5IjogIkJyZW1lciBTViIsCiAgICAgICJzY29yZSI6ICItOi0iLAogICAgICAic3RhdHVzIjogIkdlcGxhbnQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiUkxOLTIwMjUtTUQwMy0wOCIsCiAgICAgICJtYXRjaGRheSI6IDMsCiAgICAgICJraWNrb2ZmIjogIjIwMjUtMDgtMTZUMjE6MDA6MDArMDI6MDAiLAogICAgICAiaG9tZSI6ICJQaMO2bml4IEzDvGJlY2siLAogICAgICAiYXdheSI6ICJIb2xzdGVpbiBLaWVsIElJIiwKICAgICAgInNjb3JlIjogIi06LSIsCiAgICAgICJzdGF0dXMiOiAiR2VwbGFudCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJSTE4tMjAyNS1NRDAzLTA5IiwKICAgICAgIm1hdGNoZGF5IjogMywKICAgICAgImtpY2tvZmYiOiAiMjAyNS0wOC0xNlQyMjowMDowMCswMjowMCIsCiAgICAgICJob21lIjogIkVpbXNiw7x0dGVsZXIgVFYiLAogICAgICAiYXdheSI6ICJGQyBTdC4gUGF1bGkgSUkiLAogICAgICAic2NvcmUiOiAiLTotIiwKICAgICAgInN0YXR1cyI6ICJHZXBsYW50IgogICAgfSwKICAgIHsKICAgICAgImlkIjogIlJMTi0yMDI1LU1EMDQtMDEiLAogICAgICAibWF0Y2hkYXkiOiA0LAogICAgICAia2lja29mZiI6ICIyMDI1LTA4LTIzVDE0OjAwOjAwKzAyOjAwIiwKICAgICAgImhvbWUiOiAiVmZCIE9sZGVuYnVyZyIsCiAgICAgICJhd2F5IjogIldlaWNoZSBGbGVuc2J1cmcgMDgiLAogICAgICAic2NvcmUiOiAiLTotIiwKICAgICAgInN0YXR1cyI6ICJHZXBsYW50IgogICAgfSwKICAgIHsKICAgICAgImlkIjogIlJMTi0yMDI1LU1EMDQtMDIiLAogICAgICAibWF0Y2hkYXkiOiA0LAogICAgICAia2lja29mZiI6ICIyMDI1LTA4LTIzVDE1OjAwOjAwKzAyOjAwIiwKICAgICAgImhvbWUiOiAiQWx0b25hIDkzIiwKICAgICAgImF3YXkiOiAiVGV1dG9uaWEgT3R0ZW5zZW4iLAogICAgICAic2NvcmUiOiAiLTotIiwKICAgICAgInN0YXR1cyI6ICJHZXBsYW50IgogICAgfSwKICAgIHsKICAgICAgImlkIjogIlJMTi0yMDI1LU1EMDQtMDMiLAogICAgICAibWF0Y2hkYXkiOiA0LAogICAgICAia2lja29mZiI6ICIyMDI1LTA4LTIzVDE2OjAwOjAwKzAyOjAwIiwKICAgICAgImhvbWUiOiAiU1YgTWVwcGVuIiwKICAgICAgImF3YXkiOiAiU1YgRHJvY2h0ZXJzZW4vQXNzZWwiLAogICAgICAic2NvcmUiOiAiLTotIiwKICAgICAgInN0YXR1cyI6ICJHZXBsYW50IgogICAgfSwKICAgIHsKICAgICAgImlkIjogIlJMTi0yMDI1LU1EMDQtMDQiLAogICAgICAibWF0Y2hkYXkiOiA0LAogICAgICAia2lja29mZiI6ICIyMDI1LTA4LTIzVDE3OjAwOjAwKzAyOjAwIiwKICAgICAgImhvbWUiOiAiSGFubm92ZXIgOTYgSUkiLAogICAgICAiYXdheSI6ICJXZXJkZXIgQnJlbWVuIElJIiwKICAgICAgInNjb3JlIjogIi06LSIsCiAgICAgICJzdGF0dXMiOiAiR2VwbGFudCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJSTE4tMjAyNS1NRDA0LTA1IiwKICAgICAgIm1hdGNoZGF5IjogNCwKICAgICAgImtpY2tvZmYiOiAiMjAyNS0wOC0yM1QxODowMDowMCswMjowMCIsCiAgICAgICJob21lIjogIkJXIExvaG5lIiwKICAgICAgImF3YXkiOiAiRWludHJhY2h0IE5vcmRlcnN0ZWR0IiwKICAgICAgInNjb3JlIjogIi06LSIsCiAgICAgICJzdGF0dXMiOiAiR2VwbGFudCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJSTE4tMjAyNS1NRDA0LTA2IiwKICAgICAgIm1hdGNoZGF5IjogNCwKICAgICAgImtpY2tvZmYiOiAiMjAyNS0wOC0yM1QxOTowMDowMCswMjowMCIsCiAgICAgICJob21lIjogIkJyZW1lciBTViIsCiAgICAgICJhd2F5IjogIkhhbWJ1cmdlciBTViBJSSIsCiAgICAgICJzY29yZSI6ICItOi0iLAogICAgICAic3RhdHVzIjogIkdlcGxhbnQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiUkxOLTIwMjUtTUQwNC0wNyIsCiAgICAgICJtYXRjaGRheSI6IDQsCiAgICAgICJraWNrb2ZmIjogIjIwMjUtMDgtMjNUMjA6MDA6MDArMDI6MDAiLAogICAgICAiaG9tZSI6ICJIb2xzdGVpbiBLaWVsIElJIiwKICAgICAgImF3YXkiOiAiU1NWIEplZGRlbG9oIiwKICAgICAgInNjb3JlIjogIi06LSIsCiAgICAgICJzdGF0dXMiOiAiR2VwbGFudCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJSTE4tMjAyNS1NRDA0LTA4IiwKICAgICAgIm1hdGNoZGF5IjogNCwKICAgICAgImtpY2tvZmYiOiAiMjAyNS0wOC0yM1QyMTowMDowMCswMjowMCIsCiAgICAgICJob21lIjogIkZDIFN0LiBQYXVsaSBJSSIsCiAgICAgICJhd2F5IjogIlZmQiBMw7xiZWNrIiwKICAgICAgInNjb3JlIjogIi06LSIsCiAgICAgICJzdGF0dXMiOiAiR2VwbGFudCIKICAgIH0sCiAgICB7CiAgICAgICJpZCI6ICJSTE4tMjAyNS1NRDA0LTA5IiwKICAgICAgIm1hdGNoZGF5IjogNCwKICAgICAgImtpY2tvZmYiOiAiMjAyNS0wOC0yM1QyMjowMDowMCswMjowMCIsCiAgICAgICJob21lIjogIkVpbXNiw7x0dGVsZXIgVFYiLAogICAgICAiYXdheSI6ICJQaMO2bml4IEzDvGJlY2siLAogICAgICAic2NvcmUiOiAiLTotIiwKICAgICAgInN0YXR1cyI6ICJHZXBsYW50IgogICAgfSwKICAgIHsKICAgICAgImlkIjogIlJMTi0yMDI1LU1EMDUtMDEiLAogICAgICAibWF0Y2hkYXkiOiA1LAogICAgICAia2lja29mZiI6ICIyMDI1LTA4LTMwVDE0OjAwOjAwKzAyOjAwIiwKICAgICAgImhvbWUiOiAiV2VpY2hlIEZsZW5zYnVyZyAwOCIsCiAgICAgICJhd2F5IjogIkFsdG9uYSA5MyIsCiAgICAgICJzY29yZSI6ICItOi0iLAogICAgICAic3RhdHVzIjogIkdlcGxhbnQiCiAgICB9LAogICAgewogICAgICAiaWQiOiAiUkxOLTIwMjUtTUQwNS0wMiIsCiAgICAgICJtYXRjaGRheSI6IDUsCiAgICAgICJraWNrb2ZmIjogIjIwMjUtMDgtMzBUMTU6MDA6MDArMDI6MDAiLAogICAgICAiaG9tZSI6ICJWZkIgT2xkZW5idXJnIiwKICAgICAgImF3YXkiOiAiU1YgTWVwcGVuIiwKICAgICAgInNjb3JlIjogIi06LSIsCiAgICAgICJzdGF0dXMiOiAiR2VwbGFu

      */
      const REGIONALLIGA_NORD_INLINE = (() => {
        const teams = [
          'Weiche Flensburg 08',
          'SV Meppen',
          'VfB Lübeck',
          'Werder Bremen II',
          'SV Drochtersen/Assel',
          'Hannover 96 II',
          'Holstein Kiel II',
          'VfB Oldenburg',
          'FC St. Pauli II',
          'Eintracht Norderstedt',
          'Hamburger SV II',
          'Phönix Lübeck',
          'Altona 93',
          'SSV Jeddeloh',
          'BW Lohne',
          'Bremer SV',
          'Teutonia Ottensen',
          'Eimsbütteler TV'
        ];

        // Generate a double round-robin so the inline fallback covers all 34 matchdays without shipping megabytes of JSON.
        const buildRoundRobin = (teamList) => {
          const list = [...teamList];
          const rounds = teamList.length - 1;
          const pairingsPerRound = [];
          for (let round = 0; round < rounds; round += 1) {
            const roundPairings = [];
            const half = teamList.length / 2;
            for (let index = 0; index < half; index += 1) {
              let home = list[index];
              let away = list[list.length - 1 - index];
              if (index === 0 && round % 2 === 1) {
                [home, away] = [away, home];
              }
              roundPairings.push({ home, away });
            }
            pairingsPerRound.push(roundPairings);
            list.splice(1, 0, list.pop());
          }
          return pairingsPerRound;
        };

        const kickoffFor = (roundIndex, slotIndex) => {
          const kickoff = new Date(Date.UTC(2025, 7, 2, 12, 0, 0));
          kickoff.setUTCDate(kickoff.getUTCDate() + roundIndex * 7);
          kickoff.setUTCHours(12 + slotIndex, 0, 0, 0);
          return kickoff.toISOString().replace('.000Z', 'Z');
        };

        const firstLeg = buildRoundRobin(teams);
        const secondLeg = firstLeg.map((pairings) => pairings.map(({ home, away }) => ({ home: away, away: home })));
        const allRounds = [...firstLeg, ...secondLeg];

        const matches = allRounds.flatMap((roundPairings, roundIndex) => roundPairings.map((pairing, pairingIndex) => ({
          id: `RLN-2025-MD${String(roundIndex + 1).padStart(2, '0')}-${String(pairingIndex + 1).padStart(2, '0')}`,
          matchday: roundIndex + 1,
          kickoff: kickoffFor(roundIndex, pairingIndex),
          home: pairing.home,
          away: pairing.away,
          score: '-:-',
          status: 'Geplant'
        })));

        const table = [
          { rank: 1, team: 'Weiche Flensburg 08', played: 12, wins: 9, draws: 2, losses: 1, goalsFor: 30, goalsAgainst: 12, points: 29 },
          { rank: 2, team: 'SV Meppen', played: 12, wins: 8, draws: 3, losses: 1, goalsFor: 27, goalsAgainst: 14, points: 27 },
          { rank: 3, team: 'VfB Lübeck', played: 12, wins: 7, draws: 4, losses: 1, goalsFor: 24, goalsAgainst: 13, points: 25 },
          { rank: 4, team: 'Werder Bremen II', played: 12, wins: 6, draws: 4, losses: 2, goalsFor: 23, goalsAgainst: 15, points: 22 },
          { rank: 5, team: 'SV Drochtersen/Assel', played: 12, wins: 6, draws: 3, losses: 3, goalsFor: 19, goalsAgainst: 14, points: 21 },
          { rank: 6, team: 'Hannover 96 II', played: 12, wins: 6, draws: 2, losses: 4, goalsFor: 22, goalsAgainst: 19, points: 20 },
          { rank: 7, team: 'Holstein Kiel II', played: 12, wins: 5, draws: 4, losses: 3, goalsFor: 21, goalsAgainst: 18, points: 19 },
          { rank: 8, team: 'VfB Oldenburg', played: 12, wins: 5, draws: 3, losses: 4, goalsFor: 18, goalsAgainst: 17, points: 18 },
          { rank: 9, team: 'FC St. Pauli II', played: 12, wins: 4, draws: 4, losses: 4, goalsFor: 17, goalsAgainst: 18, points: 16 },
          { rank: 10, team: 'Eintracht Norderstedt', played: 12, wins: 4, draws: 3, losses: 5, goalsFor: 16, goalsAgainst: 19, points: 15 },
          { rank: 11, team: 'Hamburger SV II', played: 12, wins: 4, draws: 2, losses: 6, goalsFor: 18, goalsAgainst: 21, points: 14 },
          { rank: 12, team: 'Phönix Lübeck', played: 12, wins: 3, draws: 4, losses: 5, goalsFor: 14, goalsAgainst: 19, points: 13 },
          { rank: 13, team: 'Altona 93', played: 12, wins: 3, draws: 3, losses: 6, goalsFor: 15, goalsAgainst: 22, points: 12 },
          { rank: 14, team: 'SSV Jeddeloh', played: 12, wins: 2, draws: 5, losses: 5, goalsFor: 13, goalsAgainst: 18, points: 11 },
          { rank: 15, team: 'BW Lohne', played: 12, wins: 2, draws: 4, losses: 6, goalsFor: 11, goalsAgainst: 20, points: 10 },
          { rank: 16, team: 'Bremer SV', played: 12, wins: 2, draws: 3, losses: 7, goalsFor: 12, goalsAgainst: 24, points: 9 },
          { rank: 17, team: 'Teutonia Ottensen', played: 12, wins: 2, draws: 2, losses: 8, goalsFor: 10, goalsAgainst: 25, points: 8 },
          { rank: 18, team: 'Eimsbütteler TV', played: 12, wins: 1, draws: 3, losses: 8, goalsFor: 9, goalsAgainst: 26, points: 6 }
        ];

        return {
          lastUpdated: '2025-11-16T09:00:00+01:00',
          source: 'Regionalliga Nord – synthetischer Spielplan (Generator)',
          matches,
          table
        };
      })();

      const TENNIS_LEVELS = [
        { id: 'all', label: 'ATP & Grand Slam' },
        { id: 'atp', label: 'ATP Tour' },
        { id: 'grand-slam', label: 'Grand Slam' }
      ];

      init();

      function init() {
        populateLeagueOptions();
        DOM.sportSelect.addEventListener('change', onSportChange);
        DOM.leagueSelect.addEventListener('change', onLeagueChange);
        if (DOM.matchdayCurrent) {
          DOM.matchdayCurrent.addEventListener('change', onMatchdaySelect);
        }
        window.addEventListener('focus', () => requestRefresh(true));

        requestRefresh(true);
        startPollingLoop();
      }

      function startPollingLoop() {
        if (state.timerId) {
          clearInterval(state.timerId);
        }
        state.timerId = setInterval(() => {
          if (state.fetchInFlight) {
            return;
          }
          if (Date.now() - state.lastFetchStart < MIN_FETCH_INTERVAL_MS) {
            return;
          }
          requestRefresh(false);
        }, POLL_INTERVAL_MS);
      }

      function onSportChange(event) {
        state.sport = event.target.value;
        if (state.sport !== 'football') {
          state.matchdays = [];
          state.activeMatchdayOrder = null;
          updateMatchdayDisplay();
        }
        if (state.sport === 'football') {
          state.league = state.league || FOOTBALL_LEAGUES[0].id;
        } else if (state.sport === 'tennis') {
          state.league = state.tennisCategory || TENNIS_LEVELS[0].id;
        } else {
          state.league = null;
        }
        populateLeagueOptions();
        requestRefresh(true);
      }

      function onLeagueChange(event) {
        if (state.sport === 'football') {
          state.league = event.target.value;
        } else if (state.sport === 'tennis') {
          state.tennisCategory = event.target.value;
        }
        requestRefresh(true);
      }

      function onMatchdaySelect(event) {
        const select = event.target;
        if (!select || select.selectedIndex < 0) {
          return;
        }
        const rawValue = select.value;
        const matchdayOrder = Number.parseInt(rawValue, 10);
        const metadata = Array.isArray(state.matchdays)
          ? state.matchdays.find((entry) => entry.order === matchdayOrder)
          : null;
        const selectedOption = select.options[select.selectedIndex];
        const optionDates = selectedOption?.dataset?.dates?.split(',') || [];
        const primaryDate = metadata?.primaryDate || selectedOption?.dataset?.primaryDate || optionDates[0] || null;
        const normalizedDate = primaryDate ?? state.date;
        const changed = updateMatchdayState(normalizedDate, Number.isFinite(matchdayOrder) ? matchdayOrder : undefined);
        if (!changed) {
          return;
        }
        requestRefresh(true);
      }

      function resetMatchdayToToday() {
        const todayIso = new Date().toISOString().slice(0, 10);
        const matchdays = Array.isArray(state.matchdays) ? state.matchdays : [];
        let targetDate = todayIso;
        let targetOrder;
        if (matchdays.length) {
          const indexToday = resolveMatchdayIndexByDate(todayIso, matchdays);
          if (indexToday !== -1) {
            targetDate = matchdays[indexToday].primaryDate;
            targetOrder = matchdays[indexToday].order;
          } else {
            const closest = findClosestMatchdayIndex(todayIso, matchdays);
            if (closest !== -1) {
              targetDate = matchdays[closest].primaryDate;
              targetOrder = matchdays[closest].order;
            }
          }
        }
        if (!updateMatchdayState(targetDate, targetOrder)) {
          return;
        }
        requestRefresh(true);
      }

      function updateMatchdayState(newDate, matchdayOrderOverride) {
        const matchdays = Array.isArray(state.matchdays) ? state.matchdays : [];
        const normalizedInputDate = normalizeToIsoDate(newDate);

        if (!matchdays.length) {
          const normalizedFallback = normalizedInputDate || state.date;
          if (!normalizedFallback || normalizedFallback === state.date) {
            return false;
          }
          state.date = normalizedFallback;
          updateMatchdayDisplay();
          return true;
        }

        let targetOrder = Number.isFinite(matchdayOrderOverride)
          ? matchdayOrderOverride
          : Number.parseInt(matchdayOrderOverride, 10);
        if (!Number.isFinite(targetOrder)) {
          targetOrder = null;
        }

        let targetEntry = targetOrder != null
          ? matchdays.find((entry) => entry.order === targetOrder)
          : null;

        if (!targetEntry && normalizedInputDate) {
          targetEntry = matchdays.find((entry) => entry.primaryDate === normalizedInputDate || entry.dates?.includes(normalizedInputDate)) || null;
          if (targetEntry) {
            targetOrder = targetEntry.order;
          }
        }

        let nextDate = targetEntry?.primaryDate || normalizedInputDate || state.date;
        if (!nextDate && targetEntry?.dates?.length) {
          nextDate = targetEntry.dates[0];
        }

        if (targetOrder == null && targetEntry == null) {
          const currentIndex = getCurrentMatchdayIndex();
          const fallbackEntry = currentIndex != null ? matchdays[currentIndex] : matchdays[0];
          if (fallbackEntry) {
            targetEntry = fallbackEntry;
            targetOrder = fallbackEntry.order;
            if (!nextDate) {
              nextDate = fallbackEntry.primaryDate || fallbackEntry.dates?.[0] || state.date;
            }
          }
        }

        const normalizedDate = normalizeToIsoDate(nextDate) || state.date;
        if (normalizedDate == null) {
          return false;
        }

        const orderChanged = typeof targetOrder === 'number' && targetOrder !== state.activeMatchdayOrder;
        const dateChanged = normalizedDate !== state.date;

        if (!orderChanged && !dateChanged) {
          return false;
        }

        state.date = normalizedDate;
        if (typeof targetOrder === 'number') {
          state.activeMatchdayOrder = targetOrder;
        }
        updateMatchdayDisplay();
        return true;
      }

      function updateMatchdayDisplay() {
        if (!DOM.matchdayCurrent) {
          return;
        }
        const matchdays = Array.isArray(state.matchdays) ? state.matchdays : [];
        const select = DOM.matchdayCurrent;
        select.innerHTML = '';

        let nextValue = null;
        let hasExplicitSelection = false;

        if (matchdays.length) {
          const activeOrder = determineActiveMatchdayOrder(matchdays);
          matchdays.forEach((entry) => {
            const option = document.createElement('option');
            option.value = String(entry.order);
            option.textContent = entry.label;
            option.dataset.matchdayOrder = entry.order;
            if (entry.primaryDate) {
              option.dataset.primaryDate = entry.primaryDate;
            }
            if (entry.dates?.length) {
              option.dataset.dates = entry.dates.join(',');
            }
            if (entry.order === activeOrder) {
              option.selected = true;
              nextValue = option.value;
              hasExplicitSelection = true;
            }
            select.appendChild(option);
          });

          if (!hasExplicitSelection && select.options.length) {
            select.options[0].selected = true;
            const fallbackOrder = select.options[0].dataset.matchdayOrder ? Number.parseInt(select.options[0].dataset.matchdayOrder, 10) : null;
            if (fallbackOrder != null && !Number.isNaN(fallbackOrder)) {
              state.activeMatchdayOrder = fallbackOrder;
            }
            nextValue = select.options[0].value;
          }
          select.value = nextValue != null ? nextValue : select.options[0]?.value ?? '';
        } else {
          const option = document.createElement('option');
          option.value = state.date;
          option.textContent = formatDateForLocale(state.date) || state.date;
          option.selected = true;
          select.appendChild(option);
        }
      }

      function determineActiveMatchdayOrder(matchdays) {
        if (!matchdays.length) {
          return null;
        }
        if (state.activeMatchdayOrder != null && matchdays.some((entry) => entry.order === state.activeMatchdayOrder)) {
          return state.activeMatchdayOrder;
        }
        const indexByDate = resolveMatchdayIndexByDate(state.date, matchdays);
        if (indexByDate !== -1) {
          const order = matchdays[indexByDate].order;
          state.activeMatchdayOrder = order;
          return order;
        }
        const closestIndex = findClosestMatchdayIndex(state.date, matchdays);
        if (closestIndex !== -1) {
          const order = matchdays[closestIndex].order;
          state.activeMatchdayOrder = order;
          return order;
        }
        return null;
      }

      function resolveMatchdayIndexByDate(isoDate, matchdays) {
        if (!isoDate || !Array.isArray(matchdays)) {
          return -1;
        }
        return matchdays.findIndex((entry) => Array.isArray(entry.dates) && entry.dates.includes(isoDate));
      }

      function findClosestMatchdayIndex(isoDate, matchdays) {
        if (!Array.isArray(matchdays) || !matchdays.length) {
          return -1;
        }
        const reference = normalizeToIsoDate(isoDate);
        const referenceTime = reference ? Date.parse(reference + 'T00:00:00Z') : NaN;
        if (Number.isNaN(referenceTime)) {
          return 0;
        }
        let closestIndex = -1;
        let smallestDelta = Number.POSITIVE_INFINITY;
        matchdays.forEach((entry, index) => {
          if (!entry?.primaryDate) {
            return;
          }
          const time = Date.parse(entry.primaryDate + 'T00:00:00Z');
          if (Number.isNaN(time)) {
            return;
          }
          const delta = Math.abs(time - referenceTime);
          if (delta < smallestDelta) {
            smallestDelta = delta;
            closestIndex = index;
          }
        });
        return closestIndex;
      }

      function getCurrentMatchdayIndex() {
        const matchdays = Array.isArray(state.matchdays) ? state.matchdays : [];
        if (!matchdays.length) {
          return null;
        }
        if (state.activeMatchdayOrder != null) {
          const indexByOrder = matchdays.findIndex((entry) => entry.order === state.activeMatchdayOrder);
          if (indexByOrder !== -1) {
            return indexByOrder;
          }
        }
        const indexByDate = resolveMatchdayIndexByDate(state.date, matchdays);
        if (indexByDate !== -1) {
          return indexByDate;
        }
        const closestIndex = findClosestMatchdayIndex(state.date, matchdays);
        return closestIndex !== -1 ? closestIndex : null;
      }

      function ensureActiveMatchday(matchdays) {
        if (!Array.isArray(matchdays) || !matchdays.length) {
          state.activeMatchdayOrder = null;
          return;
        }
        if (state.activeMatchdayOrder != null && matchdays.some((entry) => entry.order === state.activeMatchdayOrder)) {
          return;
        }
        const indexByDate = resolveMatchdayIndexByDate(state.date, matchdays);
        if (indexByDate !== -1) {
          state.activeMatchdayOrder = matchdays[indexByDate].order;
          return;
        }
        const closestIndex = findClosestMatchdayIndex(state.date, matchdays);
        if (closestIndex !== -1) {
          state.activeMatchdayOrder = matchdays[closestIndex].order;
          return;
        }
        state.activeMatchdayOrder = matchdays[0].order;
      }

      function buildMatchdayMetadata(matches) {
        if (!Array.isArray(matches)) {
          return [];
        }
        const grouped = new Map();
        matches.forEach((match) => {
          const group = match?.group || match?.Group;
          const rawOrder = group?.groupOrderID ?? group?.GroupOrderID;
          const order = Number.parseInt(rawOrder, 10);
          if (!Number.isFinite(order)) {
            return;
          }
          const label = group?.groupName || group?.GroupName || order + '. Spieltag';
          const isoDate = normalizeToIsoDate(match.matchDateTimeUTC || match.matchDateTime);
          if (!grouped.has(order)) {
            grouped.set(order, {
              order,
              label,
              dates: new Set()
            });
          }
          if (isoDate) {
            grouped.get(order).dates.add(isoDate);
          }
        });

        return Array.from(grouped.values())
          .map((entry) => {
            const dates = Array.from(entry.dates).sort();
            return {
              order: entry.order,
              label: entry.label || entry.order + '. Spieltag',
              primaryDate: dates[0] || null,
              dates
            };
          })
          .filter((entry) => entry.primaryDate)
          .sort((a, b) => a.order - b.order);
      }

      function normalizeToIsoDate(value) {
        if (!value) {
          return null;
        }
        if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
          return value;
        }
        const parsed = new Date(value);
        if (Number.isNaN(parsed.getTime())) {
          return null;
        }
        return parsed.toISOString().slice(0, 10);
      }

      function formatDateForLocale(isoDate) {
        if (!isoDate) {
          return '';
        }
        const parsed = new Date(`${isoDate}T12:00:00Z`);
        if (Number.isNaN(parsed.getTime())) {
          return isoDate;
        }
        return parsed.toLocaleDateString('de-DE', {
          weekday: 'short',
          day: '2-digit',
          month: '2-digit',
          year: 'numeric'
        });
      }

      function populateLeagueOptions() {
        DOM.leagueSelect.innerHTML = '';

        if (state.sport === 'football') {
          DOM.leagueControl.classList.remove('hidden');
          FOOTBALL_LEAGUES.forEach((league) => {
            const option = document.createElement('option');
            option.value = league.id;
            option.textContent = league.label;
            if (league.id === state.league) {
              option.selected = true;
            }
            DOM.leagueSelect.appendChild(option);
          });
          if (!state.league) {
            state.league = FOOTBALL_LEAGUES[0].id;
          }
        } else if (state.sport === 'tennis') {
          DOM.leagueControl.classList.remove('hidden');
          TENNIS_LEVELS.forEach((entry) => {
            const option = document.createElement('option');
            option.value = entry.id;
            option.textContent = entry.label;
            if (entry.id === state.tennisCategory) {
              option.selected = true;
            }
            DOM.leagueSelect.appendChild(option);
          });
          state.tennisCategory = state.tennisCategory || TENNIS_LEVELS[0].id;
        } else {
          DOM.leagueControl.classList.add('hidden');
        }
      }

      async function requestRefresh(explicit) {
        setStatus(explicit ? 'Lade Live-Daten …' : 'Aktualisiere …', 'info');
        state.fetchInFlight = true;
        state.lastFetchStart = Date.now();

        try {
          if (state.sport === 'football') {
            await loadFootball();
          } else {
            await loadTennis();
          }
          const postLevel = DOM.statusBox.dataset.level;
          if (postLevel === 'info') {
            setStatus('Letzte Aktualisierung: ' + new Date().toLocaleTimeString('de-DE', {
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit'
            }), 'info');
          }
        } catch (error) {
          console.error(error);
          setStatus('Fehler beim Laden: ' + error.message, 'error');
        } finally {
          state.fetchInFlight = false;
        }
      }

      async function loadFootball() {
        const leagueConfig = FOOTBALL_LEAGUES.find((league) => league.id === state.league) || FOOTBALL_LEAGUES[0];
        const season = deriveFootballSeason(state.date);
        const shortcuts = [leagueConfig.shortcut, ...(leagueConfig.alternatives || [])].filter(Boolean);

        let regionalligaFallback = null;
        if (state.league === 'regionalliga-nord') {
          regionalligaFallback = await loadRegionalligaNordFallback(state.date);
        }

        let rawData = [];
        let lastError = null;

        for (const shortcut of shortcuts) {
          try {
            rawData = await fetchJsonWithCache(`${OPENLIGA_BASE}/getmatchdata/${shortcut}/${season}`, { cacheKey: `matches:${shortcut}:${season}`, ttl: 60000 });
            if (Array.isArray(rawData) && rawData.length > 0) {
              break;
            }
          } catch (error) {
            lastError = error;
          }
        }

        if (!Array.isArray(rawData) || rawData.length === 0) {
          const detail = lastError ? ` (${lastError.message})` : '';
          if (state.league === 'regionalliga-nord') {
            if (regionalligaFallback?.loaded) {
              const enrichedFallback = await enrichRegionalligaNordFallback(regionalligaFallback, leagueConfig, season);
              applyRegionalligaNordFallback(enrichedFallback);
              return;
            }
            const message = regionalligaFallback?.emptyMessage || 'Regionalliga Nord ist in OpenLigaDB derzeit nicht hinterlegt. Bitte eigene Datenquelle anbinden.';
            renderMatches([], message);
            renderTable([], { emptyMessage: 'Keine Tabellen-Daten hinterlegt.' });
            setStatus('Keine Daten für Regionalliga Nord verfügbar' + detail + '.', 'warning');
            return;
          }

          renderMatches([], 'Keine Spiele für den ausgewählten Tag gefunden.');
          renderTable([], { emptyMessage: 'Keine Tabellen-Daten hinterlegt.' });
          setStatus('Keine Daten für ' + leagueConfig.label + ' verfügbar' + detail + '.', 'warning');
          return;
        }

        if (Array.isArray(rawData)) {
          const metadata = buildMatchdayMetadata(rawData);
          state.matchdays = metadata;
          ensureActiveMatchday(metadata);
          updateMatchdayDisplay();
        } else {
          state.matchdays = [];
          state.activeMatchdayOrder = null;
          updateMatchdayDisplay();
        }

        const matches = rawData
          .filter((match) => matchBelongsToActiveMatchday(match))
          .map((match) => ({
            id: match.matchId || match.matchID,
            time: formatTime(match.matchDateTimeUTC || match.matchDateTime),
            home: match.team1?.teamName || match.Team1?.TeamName || 'Heim',
            away: match.team2?.teamName || match.Team2?.TeamName || 'Gast',
            score: formatScore(match.matchResults || match.MatchResults),
            status: deriveMatchStatus(match)
          }));

        if (state.league === 'regionalliga-nord' && matches.length === 0) {
          if (regionalligaFallback?.loaded) {
            const enrichedFallback = await enrichRegionalligaNordFallback(regionalligaFallback, leagueConfig, season);
            applyRegionalligaNordFallback(enrichedFallback);
            return;
          }
        }

        renderMatches(matches, 'Keine Spiele für den ausgewählten Tag gefunden.');

        const allMatchesPlanned = matches.length > 0 && matches.every((entry) => entry.status === 'Geplant');

        if (leagueConfig.table) {
          let matchday = deriveMatchday(rawData, matches);
          if (!Number.isFinite(matchday) && Number.isFinite(state.activeMatchdayOrder)) {
            matchday = state.activeMatchdayOrder;
          }
          if (!Number.isFinite(matchday)) {
            matchday = await fetchCurrentGroup(leagueConfig.shortcut, season);
          }
          const tableResult = await resolveFootballTable(leagueConfig.shortcut, season, matchday);
          if (tableResult.rows.length) {
            renderTable(tableResult.rows);
            if (tableResult.notice) {
              setStatus(tableResult.notice, 'warning');
            }
          } else {
            const emptyMessage = allMatchesPlanned
              ? 'Tabelle wird nach Abschluss des Spieltags aktualisiert.'
              : 'Keine Tabellen-Daten für diesen Spieltag verfügbar.';
            renderTable([], { emptyMessage });
            if (tableResult.error?.status === 404 || allMatchesPlanned) {
              setStatus('Für diesen Spieltag liegt noch keine Tabelle vor.', 'info');
            } else if (tableResult.error) {
              setStatus('Tabelle konnte nicht geladen werden: ' + tableResult.error.message, 'warning');
            } else {
              setStatus('Tabelle konnte nicht bestimmt werden (kein Spieltag gefunden).', 'warning');
            }
          }
        } else {
          renderTable([], { emptyMessage: 'Keine Tabellen-Daten hinterlegt.' });
        }
      }

      async function loadTennis() {
        const date = state.date;
        const level = state.tennisCategory || 'all';
        const endpoints = [
          (d) => `https://cors.isomorphic-git.org/https://www.sofascore.com/api/v1/sport/tennis/scheduled-events/${d}`,
          (d) => `https://r.jina.ai/https://www.sofascore.com/api/v1/sport/tennis/scheduled-events/${d}`,
          (d) => `https://api.sofascore.com/api/v1/sport/tennis/scheduled-events/${d}`
        ];
        let data = null;
        let lastError = null;

        for (const build of endpoints) {
          try {
            data = await fetchJson(build(date));
            if (data && data.events) {
              break;
            }
          } catch (error) {
            lastError = error;
          }
        }

        let matches = [];
        if (data && Array.isArray(data.events)) {
          matches = data.events
            .filter((event) => filterTennisEvent(event, level))
            .map((event) => ({
              id: event.id,
              time: formatTime(event.startTime * 1000, true),
              home: event.homeTeam?.name || event.shortName?.split(' - ')[0] || 'Spieler A',
              away: event.awayTeam?.name || event.shortName?.split(' - ')[1] || 'Spieler B',
              score: formatTennisScore(event),
              status: event.status?.description || 'Geplant'
            }));
        }

        if (!matches.length) {
          matches = buildDemoMatches('Tennis', level, date);
          const detail = lastError ? ` (API: ${lastError.message})` : '';
          setStatus('Keine öffentlichen Tennis-Daten verfügbar – zeige Demo-Ergebnisse' + detail, 'warning');
        }

        renderMatches(matches, 'Keine Tennisbegegnungen für den gewählten Tag gefunden.');
        hideTable();
      }

      function renderMatches(matches, emptyMessage) {
        DOM.resultsBody.innerHTML = '';
        if (!matches || !matches.length) {
          DOM.noResults.textContent = emptyMessage || 'Keine Ergebnisse für den gewählten Tag gefunden.';
          DOM.noResults.classList.remove('hidden');
          return;
        }
        DOM.noResults.classList.add('hidden');

        matches
          .sort((a, b) => (a.time || '').localeCompare(b.time || '') || a.home.localeCompare(b.home))
          .forEach((match) => {
            const row = document.createElement('tr');
            row.innerHTML = `
              <td>${escapeHtml(match.home)}</td>
              <td>${escapeHtml(match.away)}</td>
              <td class="score">${escapeHtml(match.score)}</td>
              <td>${escapeHtml(match.status)}</td>
            `;
            DOM.resultsBody.appendChild(row);
          });
      }

      function hideTable() {
        DOM.tableSection.classList.add('hidden');
        DOM.standingsBody.innerHTML = '';
      }

      function renderTable(rows, { emptyMessage = 'Keine Tabellen-Daten verfügbar.' } = {}) {
        DOM.tableSection.classList.remove('hidden');
        DOM.standingsBody.innerHTML = '';

        if (!rows || !rows.length) {
          const emptyRow = document.createElement('tr');
          emptyRow.className = 'standings-empty';
          emptyRow.innerHTML = `<td colspan="8">${escapeHtml(emptyMessage)}</td>`;
          DOM.standingsBody.appendChild(emptyRow);
          return;
        }

        rows.forEach((entry) => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${entry.rank ?? '-'}</td>
            <td>${escapeHtml(entry.team ?? '')}</td>
            <td>${entry.wins ?? '-'}</td>
            <td>${entry.draws ?? '-'}</td>
            <td>${entry.losses ?? '-'}</td>
            <td>${escapeHtml(entry.goals ?? '')}</td>
            <td>${entry.diff ?? '-'}</td>
            <td>${entry.points ?? '-'}</td>
          `;
          DOM.standingsBody.appendChild(tr);
        });
      }

      function setStatus(message, level) {
        DOM.statusBox.dataset.level = level || 'info';
        DOM.statusBox.textContent = message;
      }

      function matchesSelectedDate(dateValue, selectedDate) {
        if (!dateValue || !selectedDate) {
          return false;
        }
        const target = typeof dateValue === 'number' ? new Date(dateValue) : new Date(dateValue);
        const normalized = target.toISOString().slice(0, 10);
        return normalized === selectedDate;
      }

      function matchBelongsToActiveMatchday(match) {
        if (!match) {
          return false;
        }
        const group = match.group || match.Group;
        const rawOrder = group?.groupOrderID ?? group?.GroupOrderID;
        const matchdayOrder = rawOrder != null ? Number.parseInt(rawOrder, 10) : NaN;
        if (typeof state.activeMatchdayOrder === 'number' && Number.isFinite(state.activeMatchdayOrder) && Number.isFinite(matchdayOrder)) {
          return matchdayOrder === state.activeMatchdayOrder;
        }
        return matchesSelectedDate(match.matchDateTimeUTC || match.matchDateTime, state.date);
      }

      function deriveFootballSeason(dateStr) {
        const date = new Date(dateStr + 'T00:00:00Z');
        const year = date.getUTCFullYear();
        const month = date.getUTCMonth() + 1;
        return month >= 7 ? year : year - 1;
      }

      function deriveMatchStatus(match) {
        if (match.matchIsFinished || match.MatchIsFinished) {
          return 'Beendet';
        }
        const start = Date.parse(match.matchDateTimeUTC || match.matchDateTime);
        if (!Number.isNaN(start) && Date.now() >= start) {
          return 'Live';
        }
        return 'Geplant';
      }

      function formatTime(value, isEpochSeconds = false) {
        if (!value) {
          return '--:--';
        }
        const date = isEpochSeconds ? new Date(value) : new Date(value);
        if (Number.isNaN(date.getTime())) {
          return '--:--';
        }
        return date.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
      }

      function formatScore(results) {
        if (!results || !results.length) {
          return '-- : --';
        }
        const final = results.find((entry) => entry.resultTypeID === 2 || entry.resultTypeId === 2) || results[results.length - 1];
        if (!final) {
          return '-- : --';
        }
        const home = final.pointsTeam1 ?? final.PointsTeam1 ?? '-';
        const away = final.pointsTeam2 ?? final.PointsTeam2 ?? '-';
        return `${home} : ${away}`;
      }

      function deriveMatchday(rawData, matchesOfDay) {
        const reference = matchesOfDay?.[0];
        if (reference && reference.id) {
          const original = rawData.find((match) => (match.matchId || match.matchID) === reference.id);
          return original?.group?.groupOrderID || original?.Group?.GroupOrderID;
        }
        const fallback = rawData.find((match) => match.group?.groupOrderID || match.Group?.GroupOrderID);
        return fallback?.group?.groupOrderID || fallback?.Group?.GroupOrderID || null;
      }

      async function fetchCurrentGroup(shortcut, season) {
        try {
          const group = await fetchJsonWithCache(`${OPENLIGA_BASE}/getcurrentgroup/${shortcut}/${season}`, { cacheKey: `group:${shortcut}:${season}`, ttl: 300000 });
          return group?.groupOrderID || group?.GroupOrderID || null;
        } catch (error) {
          console.warn('getcurrentgroup failed', error);
          return null;
        }
      }

      async function resolveFootballTable(shortcut, season, matchday) {
        const attempts = [];
        const seen = new Set();

        const pushAttempt = (targetSeason, targetMatchday) => {
          const key = `${targetSeason}:${targetMatchday ?? 'full'}`;
          if (seen.has(key)) {
            return;
          }
          seen.add(key);
          attempts.push({ season: targetSeason, matchday: targetMatchday });
        };

        if (season) {
          if (matchday) {
            pushAttempt(season, matchday);
            if (matchday > 1) {
              pushAttempt(season, matchday - 1);
            }
          }
          pushAttempt(season, null);
        }
        if (season) {
          pushAttempt(season - 1, null);
        }

        let lastError = null;
        for (const attempt of attempts) {
          try {
            const suffix = attempt.matchday ? `/${attempt.matchday}` : '';
            const data = await fetchJsonWithCache(`${OPENLIGA_BASE}/getbltable/${shortcut}/${attempt.season}${suffix}`, {
              cacheKey: `table:${shortcut}:${attempt.season}:${attempt.matchday ?? 'full'}`,
              ttl: 300000
            });
            if (Array.isArray(data) && data.length) {
              const formatted = formatTable(data);
              const notice = attempt.season !== season
                ? `Tabelle der Saison ${attempt.season}/${String((attempt.season + 1) % 100).padStart(2, '0')} als Fallback.`
                : null;
              return { rows: formatted, notice };
            }
          } catch (error) {
            lastError = error;
          }
        }

        return { rows: [], error: lastError };
      }

      async function fetchJson(url, { timeout = FETCH_TIMEOUT_MS } = {}) {
        const text = await fetchText(url, { timeout, headers: { Accept: 'application/json,text/plain' } });
        if (!text) {
          return null;
        }
        const trimmed = text.trim();
        try {
          return JSON.parse(trimmed);
        } catch (error) {
          const looksLikeBase64 = url?.endsWith('.base64.txt') || /^[A-Za-z0-9+/=\s]+$/.test(trimmed);
          if (looksLikeBase64) {
            const decoded = decodeBase64Json(trimmed);
            if (decoded != null) {
              return decoded;
            }
          }
          throw error;
        }
      }

      async function fetchJsonWithCache(url, { cacheKey, ttl = 60000 } = {}) {
        if (cacheKey && cache.has(cacheKey)) {
          const entry = cache.get(cacheKey);
          if (Date.now() - entry.timestamp < ttl) {
            return entry.value;
          }
        }
        const value = await fetchJson(url);
        if (cacheKey) {
          cache.set(cacheKey, { value, timestamp: Date.now() });
        }
        return value;
      }

      function applyRegionalligaNordFallback(fallback) {
        if (!fallback) {
          return;
        }

        state.matchdays = Array.isArray(fallback.matchdays) ? fallback.matchdays : [];

        const normalizedDate = normalizeToIsoDate(fallback.selectedDate || fallback.overrideDate || state.date);
        if (typeof fallback.activeOrder === 'number' && Number.isFinite(fallback.activeOrder)) {
          state.activeMatchdayOrder = fallback.activeOrder;
        } else if (normalizedDate && state.matchdays.length) {
          const matching = state.matchdays.find((entry) => entry.primaryDate === normalizedDate || entry.dates?.includes(normalizedDate));
          if (matching) {
            state.activeMatchdayOrder = matching.order;
          }
        }

        if (normalizedDate) {
          state.date = normalizedDate;
        }

        updateMatchdayDisplay();

        renderMatches(fallback.matches, fallback.emptyMessage);

        if (Array.isArray(fallback.table) && fallback.table.length) {
          renderTable(fallback.table);
        } else {
          const tableMessage = fallback.tableMessage || 'Keine Tabellen-Daten hinterlegt.';
          renderTable([], { emptyMessage: tableMessage });
        }

        const statusMessage = fallback.message || 'Regionalliga Nord – verwende manuelle Datenquelle.';
        const statusLevel = fallback.messageLevel || 'warning';
        setStatus(statusMessage, statusLevel);
      }

      async function enrichRegionalligaNordFallback(fallback, leagueConfig, season) {
        if (!fallback || !leagueConfig?.table) {
          return fallback;
        }

        if (Array.isArray(fallback.table) && fallback.table.length) {
          return fallback;
        }

        const targetMatchday = Number.isFinite(fallback.activeOrder)
          ? fallback.activeOrder
          : Number.isFinite(state.activeMatchdayOrder)
            ? state.activeMatchdayOrder
            : null;

        if (!Number.isFinite(targetMatchday)) {
          return fallback;
        }

        const tableResult = await resolveFootballTable(leagueConfig.shortcut, season, targetMatchday);
        if (tableResult.rows.length) {
          const parts = [];
          if (fallback.message) {
            parts.push(fallback.message);
          }
          if (tableResult.notice) {
            parts.push(tableResult.notice);
          }
          return {
            ...fallback,
            table: tableResult.rows,
            tableMessage: null,
            message: parts.length ? parts.join(' · ') : fallback.message,
            messageLevel: fallback.messageLevel ?? (tableResult.notice ? 'warning' : 'info')
          };
        }

        if (tableResult.error) {
          const parts = [];
          if (fallback.message) {
            parts.push(fallback.message);
          }
          parts.push('Tabelle konnte nicht geladen werden: ' + tableResult.error.message);
          return {
            ...fallback,
            message: parts.join(' · '),
            messageLevel: fallback.messageLevel ?? 'warning'
          };
        }

        return fallback;
      }

      async function loadRegionalligaNordFallback(date) {
        const result = {
          loaded: false,
          matches: [],
          table: [],
          emptyMessage: 'Keine Regionalliga-Nord-Begegnungen in der lokalen Datenquelle gefunden.',
          availableDates: [],
          matchdays: [],
          activeOrder: null,
          selectedDate: null
        };

        const normalizedRequestedDate = normalizeToIsoDate(date);

        const formatDateLabel = (isoDate) => {
          if (!isoDate) {
            return '';
          }
          const parsed = new Date(`${isoDate}T12:00:00Z`);
          if (Number.isNaN(parsed.getTime())) {
            return isoDate;
          }
          return parsed.toLocaleDateString('de-DE', { weekday: 'short', day: '2-digit', month: '2-digit', year: 'numeric' });
        };

        let matchesJson;
        let tableJson;
        let matchesError = null;
        let tableError = null;
        let usedInlineMatches = false;
        let usedInlineTable = false;
        let matchesSourceUrl = null;
        let tableSourceUrl = null;

        const withCacheBust = (url) => {
          if (!url) {
            return url;
          }
          const token = REGIONALLIGA_NORD_FEED.cacheBust;
          if (!token) {
            return url;
          }
          const [base, hash] = url.split('#');
          const separator = base.includes('?') ? '&' : '?';
          const cacheParam = `_=${encodeURIComponent(token)}`;
          const rebuilt = `${base}${separator}${cacheParam}`;
          return hash ? `${rebuilt}#${hash}` : rebuilt;
        };

        const toCandidateArray = (value) => {
          if (!value) {
            return [];
          }
          if (Array.isArray(value)) {
            return value.filter(Boolean);
          }
          return [value];
        };

        const matchUrlCandidates = toCandidateArray(REGIONALLIGA_NORD_FEED.matchesUrl);
        if (matchUrlCandidates.length) {
          const failures = [];
          for (let index = 0; index < matchUrlCandidates.length; index += 1) {
            const baseUrl = matchUrlCandidates[index];
            try {
              const matchesUrl = withCacheBust(baseUrl);
              const cacheKey = REGIONALLIGA_NORD_FEED.cacheBust
                ? `rln-matches:${REGIONALLIGA_NORD_FEED.cacheBust}:${index}`
                : `rln-matches${index ? `:${index}` : ''}`;
              matchesJson = await fetchJsonWithCache(matchesUrl, { cacheKey, ttl: 30000 });
              matchesSourceUrl = baseUrl;
              matchesError = null;
              break;
            } catch (error) {
              failures.push(error);
            }
          }
          if (!matchesJson && failures.length) {
            matchesError = failures[failures.length - 1];
          }
        }

        const tableUrlCandidates = toCandidateArray(REGIONALLIGA_NORD_FEED.tableUrl);
        if (tableUrlCandidates.length) {
          const failures = [];
          for (let index = 0; index < tableUrlCandidates.length; index += 1) {
            const baseUrl = tableUrlCandidates[index];
            try {
              const tableUrl = withCacheBust(baseUrl);
              const cacheKey = REGIONALLIGA_NORD_FEED.cacheBust
                ? `rln-table:${REGIONALLIGA_NORD_FEED.cacheBust}:${index}`
                : `rln-table${index ? `:${index}` : ''}`;
              tableJson = await fetchJsonWithCache(tableUrl, { cacheKey, ttl: 30000 });
              tableSourceUrl = baseUrl;
              tableError = null;
              break;
            } catch (error) {
              failures.push(error);
            }
          }
          if (!tableJson && failures.length) {
            tableError = failures[failures.length - 1];
          }
        }

        const inlineData = REGIONALLIGA_NORD_INLINE;

        if ((!matchesJson || !Array.isArray(matchesJson.matches) || !matchesJson.matches.length) && inlineData?.matches?.length) {
          matchesJson = {
            ...matchesJson,
            matches: inlineData.matches,
            lastUpdated: matchesJson?.lastUpdated || inlineData.lastUpdated,
            source: matchesJson?.source || inlineData.source
          };
          usedInlineMatches = true;
          matchesSourceUrl = matchesSourceUrl || 'inline';
        }

        if ((!tableJson || !Array.isArray(tableJson.table) || !tableJson.table.length) && inlineData?.table?.length) {
          tableJson = {
            ...tableJson,
            table: inlineData.table,
            lastUpdated: tableJson?.lastUpdated || inlineData.lastUpdated,
            source: tableJson?.source || inlineData.source
          };
          usedInlineTable = true;
          tableSourceUrl = tableSourceUrl || 'inline';
        }

        const parseMatchdayValue = (match) => {
          const raw = match?.matchday ?? match?.matchDay ?? match?.round ?? match?.spieltag ?? match?.group?.order ?? match?.groupOrderID;
          const parsed = Number.parseInt(raw, 10);
          return Number.isFinite(parsed) ? parsed : null;
        };

        const getTimestamp = (match) => match?.kickoff ?? match?.date ?? match?.datetime ?? match?.matchDate ?? null;
        const allMatches = Array.isArray(matchesJson?.matches) ? matchesJson.matches : [];

        const groupedByMatchday = new Map();
        allMatches.forEach((match) => {
          const order = parseMatchdayValue(match);
          if (!Number.isFinite(order)) {
            return;
          }
          if (!groupedByMatchday.has(order)) {
            groupedByMatchday.set(order, []);
          }
          groupedByMatchday.get(order).push(match);
        });
        const hasExplicitMatchday = groupedByMatchday.size > 0;

        const availableDates = Array.from(new Set(allMatches
          .map((match) => {
            const ts = getTimestamp(match);
            if (!ts) {
              return null;
            }
            const parsed = new Date(ts);
            if (Number.isNaN(parsed.getTime())) {
              return null;
            }
            return parsed.toISOString().slice(0, 10);
          })
          .filter(Boolean)))
          .sort();

        result.availableDates = availableDates;

        if (hasExplicitMatchday) {
          result.matchdays = Array.from(groupedByMatchday.entries())
            .sort((a, b) => a[0] - b[0])
            .map(([order, matchesForOrder]) => {
              const dates = Array.from(new Set(matchesForOrder
                .map((match) => {
                  const ts = getTimestamp(match);
                  if (!ts) {
                    return null;
                  }
                  const parsed = new Date(ts);
                  return Number.isNaN(parsed.getTime()) ? null : parsed.toISOString().slice(0, 10);
                })
                .filter(Boolean))).sort();
              const primaryDate = dates[0] || null;
              const dateLabel = primaryDate ? formatDateLabel(primaryDate) : '';
              const label = dateLabel ? `${order}. Spieltag – ${dateLabel}` : `${order}. Spieltag`;
              return {
                order,
                label,
                primaryDate,
                dates
              };
            });
        } else if (availableDates.length) {
          result.matchdays = availableDates.map((isoDate, index) => {
            const displayDate = formatDateLabel(isoDate);
            const baseLabel = `${index + 1}. Spieltag`;
            return {
              order: index + 1,
              label: displayDate ? `${baseLabel} – ${displayDate}` : baseLabel,
              primaryDate: isoDate,
              dates: [isoDate]
            };
          });
        } else {
          result.matchdays = [];
        }

        const mapMatch = (match) => ({
          id: match.id || `regionalliga-nord-${getTimestamp(match) || Math.random()}`,
          time: formatTime(getTimestamp(match)),
          home: match.home || match.homeTeam || 'Heim',
          away: match.away || match.awayTeam || 'Gast',
          score: match.score ?? match.result ?? '-- : --',
          status: match.status || match.phase || 'Geplant',
          matchday: parseMatchdayValue(match)
        });

        const deriveMatchesForOrder = (order) => allMatches
          .filter((match) => parseMatchdayValue(match) === order)
          .map(mapMatch);

        const deriveMatchesForDate = (isoDate) => allMatches
          .filter((match) => matchesSelectedDate(getTimestamp(match), isoDate))
          .map(mapMatch);

        let matches = [];
        let activeOrder = Number.isFinite(state.activeMatchdayOrder) ? state.activeMatchdayOrder : null;

        if (hasExplicitMatchday && result.matchdays.length) {
          if (normalizedRequestedDate) {
            const entryFromDate = result.matchdays.find((entry) => entry.dates?.includes(normalizedRequestedDate)) || null;
            if (entryFromDate) {
              activeOrder = entryFromDate.order;
            }
          }
          if (!Number.isFinite(activeOrder)) {
            activeOrder = result.matchdays[0].order;
          }
          matches = deriveMatchesForOrder(activeOrder);
          if (!matches.length) {
            const fallbackEntry = [...result.matchdays].reverse().find((entry) => deriveMatchesForOrder(entry.order).length > 0);
            if (fallbackEntry) {
              matches = deriveMatchesForOrder(fallbackEntry.order);
              result.overrideDate = fallbackEntry.primaryDate;
              activeOrder = fallbackEntry.order;
              result.emptyMessage = `Keine Regionalliga-Nord-Spiele für Spieltag ${activeOrder} gefunden. Verfügbare Spieltage: ${result.matchdays.map((entry) => entry.order).join(', ')}.`;
              result.message = `Regionalliga Nord – keine Daten für Spieltag ${state.activeMatchdayOrder ?? '?'}; zeige Spieltag ${fallbackEntry.order}.`;
              result.messageLevel = 'warning';
            }
          }
          if (Number.isFinite(activeOrder)) {
            const activeEntry = result.matchdays.find((entry) => entry.order === activeOrder);
            if (activeEntry) {
              result.selectedDate = activeEntry.primaryDate ?? activeEntry.dates?.[0] ?? null;
            }
          }
          result.activeOrder = Number.isFinite(activeOrder) ? activeOrder : null;
        } else {
          const matchesForSelectedDate = deriveMatchesForDate(normalizedRequestedDate || date);
          matches = matchesForSelectedDate;

          if (!matches.length && availableDates.length) {
            const selectedTs = Date.parse(`${date}T00:00:00Z`);
            let fallbackDate = availableDates[availableDates.length - 1];
            if (!Number.isNaN(selectedTs)) {
              const pastOrEqual = availableDates.filter((candidate) => Date.parse(`${candidate}T00:00:00Z`) <= selectedTs);
              if (pastOrEqual.length) {
                fallbackDate = pastOrEqual[pastOrEqual.length - 1];
              } else {
                fallbackDate = availableDates[0];
              }
            }

            const fallbackMatches = deriveMatchesForDate(fallbackDate);

            if (fallbackMatches.length) {
              matches = fallbackMatches;
              result.overrideDate = fallbackDate;
              result.emptyMessage = `Keine Regionalliga-Nord-Spiele am ${formatDateLabel(date)} gefunden. Verfügbare Daten: ${availableDates.map(formatDateLabel).join(', ')}.`;
              result.message = `Regionalliga Nord – keine Daten für ${formatDateLabel(date)}, zeige ${formatDateLabel(fallbackDate)}.`;
              result.messageLevel = 'warning';
            }
          }

          const effectiveDate = normalizeToIsoDate(result.overrideDate || normalizedRequestedDate);
          if (effectiveDate && availableDates.includes(effectiveDate)) {
            result.selectedDate = effectiveDate;
            result.activeOrder = availableDates.indexOf(effectiveDate) + 1;
          } else if (availableDates.length) {
            result.selectedDate = availableDates[0];
            result.activeOrder = 1;
          } else if (effectiveDate) {
            result.selectedDate = effectiveDate;
          }
        }

        const table = formatRegionalligaNordTable(Array.isArray(tableJson?.table) ? tableJson.table : []);

        result.matches = matches;
        result.table = table;
        result.loaded = matches.length > 0 || table.length > 0;

        const infoChunks = [];
        if (matchesJson?.lastUpdated) {
          infoChunks.push(`Spiele-Stand ${matchesJson.lastUpdated}`);
        }
        if (tableJson?.lastUpdated) {
          infoChunks.push(`Tabelle-Stand ${tableJson.lastUpdated}`);
        }
        if (matchesJson?.source) {
          infoChunks.push(matchesJson.source);
        }
        if (typeof matchesSourceUrl === 'string' && matchesSourceUrl !== 'inline') {
          infoChunks.push(`Spiele-Datei ${matchesSourceUrl}`);
        }
        if (tableJson?.source && tableJson.source !== matchesJson?.source) {
          infoChunks.push(tableJson.source);
        }
        if (typeof tableSourceUrl === 'string' && tableSourceUrl !== 'inline' && tableSourceUrl !== matchesSourceUrl) {
          infoChunks.push(`Tabelle-Datei ${tableSourceUrl}`);
        }
        if (availableDates.length) {
          infoChunks.push(`Verfügbare Spieltage: ${availableDates.map(formatDateLabel).join(', ')}`);
        }

        if (result.loaded) {
          if (result.message) {
            if (infoChunks.length) {
              result.message += ` (${infoChunks.join(' · ')})`;
            }
          } else {
            result.message = 'Regionalliga Nord – lokale Datenquelle aktiv' + (infoChunks.length ? ` (${infoChunks.join(' · ')})` : '');
            result.messageLevel = 'warning';
          }
          if ((matchesError && usedInlineMatches) || (tableError && usedInlineTable)) {
            const failureNotes = [];
            if (matchesError && usedInlineMatches) {
              failureNotes.push('Spiele-Datei nicht erreichbar' + (matchesError.message ? ` (${matchesError.message})` : ''));
            }
            if (tableError && usedInlineTable) {
              failureNotes.push('Tabellen-Datei nicht erreichbar' + (tableError.message ? ` (${tableError.message})` : ''));
            }
            if (failureNotes.length) {
              const failureDetail = failureNotes.join(' · ');
              result.message = result.message.includes(failureDetail)
                ? result.message
                : `${result.message} · ${failureDetail}`;
            }
          }
          if (usedInlineMatches || usedInlineTable) {
            const inlineHint = 'Inline-Daten eingebettet – bitte regelmäßig im Quelltext oder unter /data aktualisieren.';
            result.message = result.message.includes(inlineHint)
              ? result.message
              : `${result.message} · ${inlineHint}`;
          }
        } else if (matchesError || tableError) {
          const details = [matchesError?.message, tableError?.message].filter(Boolean).join(' | ');
          result.message = 'Regionalliga Nord – lokale Datenquelle konnte nicht geladen werden' + (details ? ` (${details})` : '');
          result.messageLevel = 'error';
        } else if (availableDates.length) {
          result.emptyMessage = `Keine Regionalliga-Nord-Spiele am ${formatDateLabel(date)} gefunden. Verfügbare Daten: ${availableDates.map(formatDateLabel).join(', ')}.`;
        }

        return result;
      }

      function formatRegionalligaNordTable(entries) {
        if (!Array.isArray(entries)) {
          return [];
        }
        return entries.map((entry, index) => {
          const goalsFor = entry.goalsFor ?? entry.goals_for ?? entry.goals ?? entry.gf ?? 0;
          const goalsAgainst = entry.goalsAgainst ?? entry.goals_against ?? entry.opponentGoals ?? entry.ga ?? 0;
          const diff = entry.goalDifference ?? entry.goal_difference ?? (Number.isFinite(goalsFor) && Number.isFinite(goalsAgainst) ? goalsFor - goalsAgainst : undefined);
          return {
            rank: entry.rank ?? entry.position ?? index + 1,
            team: entry.team ?? entry.teamName ?? entry.name ?? 'Team',
            wins: entry.wins ?? entry.win ?? entry.won ?? null,
            draws: entry.draws ?? entry.draw ?? entry.ties ?? null,
            losses: entry.losses ?? entry.loss ?? entry.lost ?? null,
            goals: `${goalsFor}:${goalsAgainst}`,
            diff: diff ?? null,
            points: entry.points ?? entry.p ?? entry.pts ?? null
          };
        });
      }

      function filterTennisEvent(event, level) {
        if (!event) {
          return false;
        }
        const category = event.tournament?.category?.name?.toLowerCase?.() || event.tournament?.uniqueTournament?.category?.name?.toLowerCase?.() || '';
        if (level === 'all') {
          return category.includes('atp') || category.includes('grand slam') || event.tournament?.name?.toLowerCase?.().includes('grand slam');
        }
        if (level === 'atp') {
          return category.includes('atp');
        }
        if (level === 'grand-slam') {
          return category.includes('grand slam') || event.tournament?.name?.toLowerCase?.().includes('grand slam');
        }
        return true;
      }

      function formatTennisScore(event) {
        if (!event?.homeScore || !event?.awayScore) {
          return event?.status?.description === 'Finished' ? '—' : '-- : --';
        }
        const sets = [0, 1, 2, 3, 4]
          .map((index) => {
            const home = event.homeScore[`set${index + 1}`];
            const away = event.awayScore[`set${index + 1}`];
            if (typeof home === 'number' && typeof away === 'number') {
              return `${home}:${away}`;
            }
            return null;
          })
          .filter(Boolean);
        if (!sets.length) {
          const games = `${event.homeScore.current ?? 0}:${event.awayScore.current ?? 0}`;
          return games;
        }
        return sets.join(' · ');
      }

      function buildDemoMatches(sport, variant, date) {
        const baseTime = new Date(date + 'T12:00:00');
        const randomScore = () => `${Math.floor(Math.random() * 5)}:${Math.floor(Math.random() * 5)}`;
        const labels = {
          Tennis: [
            ['Spieler A', 'Spieler B'],
            ['Spieler C', 'Spieler D'],
            ['Spieler E', 'Spieler F']
          ]
        };
        const list = labels[sport] || [
          ['Team A', 'Team B'],
          ['Team C', 'Team D'],
          ['Team E', 'Team F']
        ];
        return list.map((pair, index) => ({
          id: `${sport}-${variant}-${index}`,
          time: formatTime(baseTime.getTime() + index * 3600000),
          home: pair[0],
          away: pair[1],
          score: randomScore(),
          status: 'Live (Demo)'
        }));
      }

      function formatTable(entries) {
        if (!Array.isArray(entries)) {
          return [];
        }
        return entries.map((entry, index) => ({
          rank: entry.rank ?? entry.Rank ?? index + 1,
          team: entry.teamName ?? entry.TeamName ?? entry.team?.teamName ?? 'Team',
          wins: entry.won ?? entry.Won,
          draws: entry.draw ?? entry.Draw,
          losses: entry.lost ?? entry.Lost,
          goals: `${entry.goals ?? entry.Goals ?? 0}:${entry.opponentGoals ?? entry.OpponentGoals ?? 0}`,
          diff: entry.goalDifference ?? entry.GoalDifference,
          points: entry.points ?? entry.Points
        }));
      }

      function escapeHtml(value) {
        return String(value ?? '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }
    })();
  </script>
</body>
</html>
